import{r as t,g as s,h as i,H as e}from"./p-f6170640.js";class n{constructor(t){void 0===t&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const s=this.elements;s[0]=t.x,s[4]=t.y,s[8]=t.z}getTrace(t){void 0===t&&(t=new o);const s=this.elements;return t.x=s[0],t.y=s[4],t.z=s[8],t}vmult(t,s){void 0===s&&(s=new o);const i=this.elements,e=t.x,n=t.y,h=t.z;return s.x=i[0]*e+i[1]*n+i[2]*h,s.y=i[3]*e+i[4]*n+i[5]*h,s.z=i[6]*e+i[7]*n+i[8]*h,s}smult(t){for(let s=0;s<this.elements.length;s++)this.elements[s]*=t}mmult(t,s){void 0===s&&(s=new n);const i=this.elements,e=t.elements,h=s.elements,o=i[0],r=i[1],c=i[2],l=i[3],a=i[4],u=i[5],w=i[6],f=i[7],d=i[8],p=e[0],v=e[1],g=e[2],m=e[3],y=e[4],M=e[5],b=e[6],x=e[7],$=e[8];return h[0]=o*p+r*m+c*b,h[1]=o*v+r*y+c*x,h[2]=o*g+r*M+c*$,h[3]=l*p+a*m+u*b,h[4]=l*v+a*y+u*x,h[5]=l*g+a*M+u*$,h[6]=w*p+f*m+d*b,h[7]=w*v+f*y+d*x,h[8]=w*g+f*M+d*$,s}scale(t,s){void 0===s&&(s=new n);const i=this.elements,e=s.elements;for(let s=0;3!==s;s++)e[3*s+0]=t.x*i[3*s+0],e[3*s+1]=t.y*i[3*s+1],e[3*s+2]=t.z*i[3*s+2];return s}solve(t,s){void 0===s&&(s=new o);const i=[];let e,n;for(e=0;e<12;e++)i.push(0);for(e=0;e<3;e++)for(n=0;n<3;n++)i[e+4*n]=this.elements[e+3*n];i[3]=t.x,i[7]=t.y,i[11]=t.z;let h=3;const r=h;let c,l;do{if(e=r-h,0===i[e+4*e])for(n=e+1;n<r;n++)if(0!==i[e+4*n]){c=4;do{l=4-c,i[l+4*e]+=i[l+4*n]}while(--c);break}if(0!==i[e+4*e])for(n=e+1;n<r;n++){const t=i[e+4*n]/i[e+4*e];c=4;do{l=4-c,i[l+4*n]=l<=e?0:i[l+4*n]-i[l+4*e]*t}while(--c)}}while(--h);if(s.z=i[11]/i[10],s.y=(i[7]-i[6]*s.z)/i[5],s.x=(i[3]-i[2]*s.z-i[1]*s.y)/i[0],isNaN(s.x)||isNaN(s.y)||isNaN(s.z)||s.x===1/0||s.y===1/0||s.z===1/0)throw`Could not solve equation! Got x=[${s.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return s}e(t,s,i){if(void 0===i)return this.elements[s+3*t];this.elements[s+3*t]=i}copy(t){for(let s=0;s<t.elements.length;s++)this.elements[s]=t.elements[s];return this}toString(){let t="";for(let s=0;s<9;s++)t+=this.elements[s]+",";return t}reverse(t){void 0===t&&(t=new n);const s=h;let i,e;for(i=0;i<3;i++)for(e=0;e<3;e++)s[i+6*e]=this.elements[i+3*e];s[3]=1,s[9]=0,s[15]=0,s[4]=0,s[10]=1,s[16]=0,s[5]=0,s[11]=0,s[17]=1;let o=3;const r=o;let c,l;do{if(i=r-o,0===s[i+6*i])for(e=i+1;e<r;e++)if(0!==s[i+6*e]){c=6;do{l=6-c,s[l+6*i]+=s[l+6*e]}while(--c);break}if(0!==s[i+6*i])for(e=i+1;e<r;e++){const t=s[i+6*e]/s[i+6*i];c=6;do{l=6-c,s[l+6*e]=l<=i?0:s[l+6*e]-s[l+6*i]*t}while(--c)}}while(--o);i=2;do{e=i-1;do{const t=s[i+6*e]/s[i+6*i];c=6;do{l=6-c,s[l+6*e]=s[l+6*e]-s[l+6*i]*t}while(--c)}while(e--)}while(--i);i=2;do{const t=1/s[i+6*i];c=6;do{l=6-c,s[l+6*i]=s[l+6*i]*t}while(--c)}while(i--);i=2;do{e=2;do{if(l=s[3+e+6*i],isNaN(l)||l===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,e,l)}while(e--)}while(i--);return t}setRotationFromQuaternion(t){const s=t.x,i=t.y,e=t.z,n=t.w,h=s+s,o=i+i,r=e+e,c=s*h,l=s*o,a=s*r,u=i*o,w=i*r,f=e*r,d=n*h,p=n*o,v=n*r,g=this.elements;return g[0]=1-(u+f),g[1]=l-v,g[2]=a+p,g[3]=l+v,g[4]=1-(c+f),g[5]=w-d,g[6]=a-p,g[7]=w+d,g[8]=1-(c+u),this}transpose(t){void 0===t&&(t=new n);const s=this.elements,i=t.elements;let e;return i[0]=s[0],i[4]=s[4],i[8]=s[8],e=s[1],i[1]=s[3],i[3]=e,e=s[2],i[2]=s[6],i[6]=e,e=s[5],i[5]=s[7],i[7]=e,t}}const h=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class o{constructor(t,s,i){void 0===t&&(t=0),void 0===s&&(s=0),void 0===i&&(i=0),this.x=t,this.y=s,this.z=i}cross(t,s){void 0===s&&(s=new o);const i=t.x,e=t.y,n=t.z,h=this.x,r=this.y,c=this.z;return s.x=r*n-c*e,s.y=c*i-h*n,s.z=h*e-r*i,s}set(t,s,i){return this.x=t,this.y=s,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(t,s){if(!s)return new o(this.x+t.x,this.y+t.y,this.z+t.z);s.x=t.x+this.x,s.y=t.y+this.y,s.z=t.z+this.z}vsub(t,s){if(!s)return new o(this.x-t.x,this.y-t.y,this.z-t.z);s.x=this.x-t.x,s.y=this.y-t.y,s.z=this.z-t.z}crossmat(){return new n([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,s=this.y,i=this.z,e=Math.sqrt(t*t+s*s+i*i);if(e>0){const t=1/e;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return e}unit(t){void 0===t&&(t=new o);const s=this.x,i=this.y,e=this.z;let n=Math.sqrt(s*s+i*i+e*e);return n>0?(n=1/n,t.x=s*n,t.y=i*n,t.z=e*n):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,s=this.y,i=this.z;return Math.sqrt(t*t+s*s+i*i)}lengthSquared(){return this.dot(this)}distanceTo(t){const s=this.x,i=this.y,e=this.z,n=t.x,h=t.y,o=t.z;return Math.sqrt((n-s)*(n-s)+(h-i)*(h-i)+(o-e)*(o-e))}distanceSquared(t){const s=this.x,i=this.y,e=this.z,n=t.x,h=t.y,o=t.z;return(n-s)*(n-s)+(h-i)*(h-i)+(o-e)*(o-e)}scale(t,s){void 0===s&&(s=new o);const i=this.y,e=this.z;return s.x=t*this.x,s.y=t*i,s.z=t*e,s}vmul(t,s){return void 0===s&&(s=new o),s.x=t.x*this.x,s.y=t.y*this.y,s.z=t.z*this.z,s}addScaledVector(t,s,i){return void 0===i&&(i=new o),i.x=this.x+t*s.x,i.y=this.y+t*s.y,i.z=this.z+t*s.z,i}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return void 0===t&&(t=new o),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,s){const i=this.length();if(i>0){const e=r,n=1/i;e.set(this.x*n,this.y*n,this.z*n);const h=c;Math.abs(e.x)<.9?(h.set(1,0,0),e.cross(h,t)):(h.set(0,1,0),e.cross(h,t)),e.cross(t,s)}else t.set(1,0,0),s.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,s,i){const e=this.x,n=this.y,h=this.z;i.x=e+(t.x-e)*s,i.y=n+(t.y-n)*s,i.z=h+(t.z-h)*s}almostEquals(t,s){return void 0===s&&(s=1e-6),!(Math.abs(this.x-t.x)>s||Math.abs(this.y-t.y)>s||Math.abs(this.z-t.z)>s)}almostZero(t){return void 0===t&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,s){return this.negate(l),l.almostEquals(t,s)}clone(){return new o(this.x,this.y,this.z)}}o.ZERO=new o(0,0,0),o.UNIT_X=new o(1,0,0),o.UNIT_Y=new o(0,1,0),o.UNIT_Z=new o(0,0,1);const r=new o,c=new o,l=new o;class a{constructor(t){void 0===t&&(t={}),this.lowerBound=new o,this.upperBound=new o,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,s,i,e){const n=this.lowerBound,h=this.upperBound,o=i;n.copy(t[0]),o&&o.vmult(n,n),h.copy(n);for(let s=1;s<t.length;s++){let i=t[s];o&&(o.vmult(i,u),i=u),i.x>h.x&&(h.x=i.x),i.x<n.x&&(n.x=i.x),i.y>h.y&&(h.y=i.y),i.y<n.y&&(n.y=i.y),i.z>h.z&&(h.z=i.z),i.z<n.z&&(n.z=i.z)}return s&&(s.vadd(n,n),s.vadd(h,h)),e&&(n.x-=e,n.y-=e,n.z-=e,h.x+=e,h.y+=e,h.z+=e),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return(new a).copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const s=this.lowerBound,i=this.upperBound,e=t.lowerBound,n=t.upperBound;return(e.x<=i.x&&i.x<=n.x||s.x<=n.x&&n.x<=i.x)&&(e.y<=i.y&&i.y<=n.y||s.y<=n.y&&n.y<=i.y)&&(e.z<=i.z&&i.z<=n.z||s.z<=n.z&&n.z<=i.z)}volume(){const t=this.lowerBound,s=this.upperBound;return(s.x-t.x)*(s.y-t.y)*(s.z-t.z)}contains(t){const s=this.lowerBound,i=this.upperBound,e=t.lowerBound,n=t.upperBound;return s.x<=e.x&&i.x>=n.x&&s.y<=e.y&&i.y>=n.y&&s.z<=e.z&&i.z>=n.z}getCorners(t,s,i,e,n,h,o,r){const c=this.lowerBound,l=this.upperBound;t.copy(c),s.set(l.x,c.y,c.z),i.set(l.x,l.y,c.z),e.set(c.x,l.y,l.z),n.set(l.x,c.y,l.z),h.set(c.x,l.y,c.z),o.set(c.x,c.y,l.z),r.copy(l)}toLocalFrame(t,s){const i=w;this.getCorners(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7]);for(let s=0;8!==s;s++){const e=i[s];t.pointToLocal(e,e)}return s.setFromPoints(i)}toWorldFrame(t,s){const i=w;this.getCorners(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7]);for(let s=0;8!==s;s++){const e=i[s];t.pointToWorld(e,e)}return s.setFromPoints(i)}overlapsRay(t){const{direction:s,from:i}=t,e=1/s.x,n=1/s.y,h=1/s.z,o=(this.lowerBound.x-i.x)*e,r=(this.upperBound.x-i.x)*e,c=(this.lowerBound.y-i.y)*n,l=(this.upperBound.y-i.y)*n,a=(this.lowerBound.z-i.z)*h,u=(this.upperBound.z-i.z)*h,w=Math.max(Math.max(Math.min(o,r),Math.min(c,l)),Math.min(a,u)),f=Math.min(Math.min(Math.max(o,r),Math.max(c,l)),Math.max(a,u));return!(f<0||w>f)}}const u=new o,w=[new o,new o,new o,new o,new o,new o,new o,new o];class f{constructor(){this.matrix=[]}get(t,s){let{index:i}=t,{index:e}=s;if(e>i){const t=e;e=i,i=t}return this.matrix[(i*(i+1)>>1)+e-1]}set(t,s,i){let{index:e}=t,{index:n}=s;if(n>e){const t=n;n=e,e=t}this.matrix[(e*(e+1)>>1)+n-1]=i?1:0}reset(){for(let t=0,s=this.matrix.length;t!==s;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class d{addEventListener(t,s){void 0===this._listeners&&(this._listeners={});const i=this._listeners;return void 0===i[t]&&(i[t]=[]),i[t].includes(s)||i[t].push(s),this}hasEventListener(t,s){if(void 0===this._listeners)return!1;const i=this._listeners;return!(void 0===i[t]||!i[t].includes(s))}hasAnyEventListener(t){return void 0!==this._listeners&&void 0!==this._listeners[t]}removeEventListener(t,s){if(void 0===this._listeners)return this;const i=this._listeners;if(void 0===i[t])return this;const e=i[t].indexOf(s);return-1!==e&&i[t].splice(e,1),this}dispatchEvent(t){if(void 0===this._listeners)return this;const s=this._listeners[t.type];if(void 0!==s){t.target=this;for(let i=0,e=s.length;i<e;i++)s[i].call(this,t)}return this}}class p{constructor(t,s,i,e){void 0===t&&(t=0),void 0===s&&(s=0),void 0===i&&(i=0),void 0===e&&(e=1),this.x=t,this.y=s,this.z=i,this.w=e}set(t,s,i,e){return this.x=t,this.y=s,this.z=i,this.w=e,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,s){const i=Math.sin(.5*s);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*s),this}toAxisAngle(t){void 0===t&&(t=new o),this.normalize();const s=2*Math.acos(this.w),i=Math.sqrt(1-this.w*this.w);return i<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/i,t.y=this.y/i,t.z=this.z/i),[t,s]}setFromVectors(t,s){if(t.isAntiparallelTo(s)){const s=v;t.tangents(s,g),this.setFromAxisAngle(s,Math.PI)}else{const i=t.cross(s);this.x=i.x,this.y=i.y,this.z=i.z,this.w=Math.sqrt(t.length()**2*s.length()**2)+t.dot(s),this.normalize()}return this}mult(t,s){void 0===s&&(s=new p);const i=this.x,e=this.y,n=this.z,h=this.w,o=t.x,r=t.y,c=t.z,l=t.w;return s.x=i*l+h*o+e*c-n*r,s.y=e*l+h*r+n*o-i*c,s.z=n*l+h*c+i*r-e*o,s.w=h*l-i*o-e*r-n*c,s}inverse(t){void 0===t&&(t=new p);const s=this.x,i=this.y,e=this.z,n=this.w;this.conjugate(t);const h=1/(s*s+i*i+e*e+n*n);return t.x*=h,t.y*=h,t.z*=h,t.w*=h,t}conjugate(t){return void 0===t&&(t=new p),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,s){void 0===s&&(s=new o);const i=t.x,e=t.y,n=t.z,h=this.x,r=this.y,c=this.z,l=this.w,a=l*i+r*n-c*e,u=l*e+c*i-h*n,w=l*n+h*e-r*i,f=-h*i-r*e-c*n;return s.x=a*l+f*-h+u*-c-w*-r,s.y=u*l+f*-r+w*-h-a*-c,s.z=w*l+f*-c+a*-r-u*-h,s}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,s){let i,e,n;void 0===s&&(s="YZX");const h=this.x,o=this.y,r=this.z,c=this.w;switch(s){case"YZX":const t=h*o+r*c;if(t>.499&&(i=2*Math.atan2(h,c),e=Math.PI/2,n=0),t<-.499&&(i=-2*Math.atan2(h,c),e=-Math.PI/2,n=0),void 0===i){const s=h*h,l=r*r;i=Math.atan2(2*o*c-2*h*r,1-o*o*2-2*l),e=Math.asin(2*t),n=Math.atan2(2*h*c-2*o*r,1-2*s-2*l)}break;default:throw new Error(`Euler order ${s} not supported yet.`)}t.y=i,t.z=e,t.x=n}setFromEuler(t,s,i,e){void 0===e&&(e="XYZ");const n=Math.cos(t/2),h=Math.cos(s/2),o=Math.cos(i/2),r=Math.sin(t/2),c=Math.sin(s/2),l=Math.sin(i/2);return"XYZ"===e?(this.x=r*h*o+n*c*l,this.y=n*c*o-r*h*l,this.z=n*h*l+r*c*o,this.w=n*h*o-r*c*l):"YXZ"===e?(this.x=r*h*o+n*c*l,this.y=n*c*o-r*h*l,this.z=n*h*l-r*c*o,this.w=n*h*o+r*c*l):"ZXY"===e?(this.x=r*h*o-n*c*l,this.y=n*c*o+r*h*l,this.z=n*h*l+r*c*o,this.w=n*h*o-r*c*l):"ZYX"===e?(this.x=r*h*o-n*c*l,this.y=n*c*o+r*h*l,this.z=n*h*l-r*c*o,this.w=n*h*o+r*c*l):"YZX"===e?(this.x=r*h*o+n*c*l,this.y=n*c*o+r*h*l,this.z=n*h*l-r*c*o,this.w=n*h*o-r*c*l):"XZY"===e&&(this.x=r*h*o-n*c*l,this.y=n*c*o-r*h*l,this.z=n*h*l+r*c*o,this.w=n*h*o+r*c*l),this}clone(){return new p(this.x,this.y,this.z,this.w)}slerp(t,s,i){void 0===i&&(i=new p);const e=this.x,n=this.y,h=this.z,o=this.w;let r,c,l,a,u,w=t.x,f=t.y,d=t.z,v=t.w;return c=e*w+n*f+h*d+o*v,c<0&&(c=-c,w=-w,f=-f,d=-d,v=-v),1-c>1e-6?(r=Math.acos(c),l=Math.sin(r),a=Math.sin((1-s)*r)/l,u=Math.sin(s*r)/l):(a=1-s,u=s),i.x=a*e+u*w,i.y=a*n+u*f,i.z=a*h+u*d,i.w=a*o+u*v,i}integrate(t,s,i,e){void 0===e&&(e=new p);const n=t.x*i.x,h=t.y*i.y,o=t.z*i.z,r=this.x,c=this.y,l=this.z,a=this.w,u=.5*s;return e.x+=u*(n*a+h*l-o*c),e.y+=u*(h*a+o*r-n*l),e.z+=u*(o*a+n*c-h*r),e.w+=u*(-n*r-h*c-o*l),e}}const v=new o,g=new o;class m{constructor(t){void 0===t&&(t={}),this.id=m.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=!t.collisionResponse||t.collisionResponse,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,s){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,s,i,e){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}m.idCounter=0,m.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class y{constructor(t){void 0===t&&(t={}),this.position=new o,this.quaternion=new p,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,s){return y.pointToLocalFrame(this.position,this.quaternion,t,s)}pointToWorld(t,s){return y.pointToWorldFrame(this.position,this.quaternion,t,s)}vectorToWorldFrame(t,s){return void 0===s&&(s=new o),this.quaternion.vmult(t,s),s}static pointToLocalFrame(t,s,i,e){return void 0===e&&(e=new o),i.vsub(t,e),s.conjugate(M),M.vmult(e,e),e}static pointToWorldFrame(t,s,i,e){return void 0===e&&(e=new o),s.vmult(i,e),e.vadd(t,e),e}static vectorToWorldFrame(t,s,i){return void 0===i&&(i=new o),t.vmult(s,i),i}static vectorToLocalFrame(t,s,i,e){return void 0===e&&(e=new o),s.w*=-1,s.vmult(i,e),s.w*=-1,e}}const M=new p;class b extends m{constructor(t){void 0===t&&(t={});const{vertices:s=[],faces:i=[],normals:e=[],axes:n,boundingSphereRadius:h}=t;super({type:m.types.CONVEXPOLYHEDRON}),this.vertices=s,this.faces=i,this.faceNormals=e,0===this.faceNormals.length&&this.computeNormals(),h?this.boundingSphereRadius=h:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,s=this.vertices,i=this.uniqueEdges;i.length=0;const e=new o;for(let n=0;n!==t.length;n++){const h=t[n],o=h.length;for(let t=0;t!==o;t++){s[h[t]].vsub(s[h[(t+1)%o]],e),e.normalize();let n=!1;for(let t=0;t!==i.length;t++)if(i[t].almostEquals(e)||i[t].almostEquals(e)){n=!0;break}n||i.push(e.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const s=this.faceNormals[t]||new o;if(this.getFaceNormal(t,s),s.negate(s),this.faceNormals[t]=s,s.dot(this.vertices[this.faces[t][0]])<0){console.error(`.faceNormals[${t}] = Vec3(${s.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,s){const i=this.faces[t];b.computeNormal(this.vertices[i[0]],this.vertices[i[1]],this.vertices[i[2]],s)}static computeNormal(t,s,i,e){const n=new o,h=new o;s.vsub(t,h),i.vsub(s,n),n.cross(h,e),e.isZero()||e.normalize()}clipAgainstHull(t,s,i,e,n,h,r,c,l){const a=new o;let u=-1,w=-Number.MAX_VALUE;for(let t=0;t<i.faces.length;t++){a.copy(i.faceNormals[t]),n.vmult(a,a);const s=a.dot(h);s>w&&(w=s,u=t)}const f=[];for(let t=0;t<i.faces[u].length;t++){const s=i.vertices[i.faces[u][t]],h=new o;h.copy(s),n.vmult(h,h),e.vadd(h,h),f.push(h)}u>=0&&this.clipFaceAgainstHull(h,t,s,f,r,c,l)}findSeparatingAxis(t,s,i,e,n,h,r,c){const l=new o,a=new o,u=new o,w=new o,f=new o,d=new o;let p=Number.MAX_VALUE;const v=this;if(v.uniqueAxes)for(let o=0;o!==v.uniqueAxes.length;o++){i.vmult(v.uniqueAxes[o],l);const r=v.testSepAxis(l,t,s,i,e,n);if(!1===r)return!1;r<p&&(p=r,h.copy(l))}else{const o=r?r.length:v.faces.length;for(let c=0;c<o;c++){l.copy(v.faceNormals[r?r[c]:c]),i.vmult(l,l);const o=v.testSepAxis(l,t,s,i,e,n);if(!1===o)return!1;o<p&&(p=o,h.copy(l))}}if(t.uniqueAxes)for(let o=0;o!==t.uniqueAxes.length;o++){n.vmult(t.uniqueAxes[o],a);const r=v.testSepAxis(a,t,s,i,e,n);if(!1===r)return!1;r<p&&(p=r,h.copy(a))}else{const o=c?c.length:t.faces.length;for(let r=0;r<o;r++){a.copy(t.faceNormals[c?c[r]:r]),n.vmult(a,a);const o=v.testSepAxis(a,t,s,i,e,n);if(!1===o)return!1;o<p&&(p=o,h.copy(a))}}for(let o=0;o!==v.uniqueEdges.length;o++){i.vmult(v.uniqueEdges[o],w);for(let o=0;o!==t.uniqueEdges.length;o++)if(n.vmult(t.uniqueEdges[o],f),w.cross(f,d),!d.almostZero()){d.normalize();const o=v.testSepAxis(d,t,s,i,e,n);if(!1===o)return!1;o<p&&(p=o,h.copy(d))}}return e.vsub(s,u),u.dot(h)>0&&h.negate(h),!0}testSepAxis(t,s,i,e,n,h){b.project(this,t,i,e,x),b.project(s,t,n,h,$);const o=x[0],r=x[1],c=$[0],l=$[1];if(o<l||c<r)return!1;const a=o-l,u=c-r;return a<u?a:u}calculateLocalInertia(t,s){const i=new o,e=new o;this.computeLocalAABB(e,i);const n=i.x-e.x,h=i.y-e.y,r=i.z-e.z;s.x=1/12*t*(2*h*2*h+2*r*2*r),s.y=1/12*t*(2*n*2*n+2*r*2*r),s.z=1/12*t*(2*h*2*h+2*n*2*n)}getPlaneConstantOfFace(t){return-this.faceNormals[t].dot(this.vertices[this.faces[t][0]])}clipFaceAgainstHull(t,s,i,e,n,h,r){const c=new o,l=new o,a=new o,u=new o,w=new o,f=new o,d=new o,p=new o,v=this,g=e,m=[];let y=-1,M=Number.MAX_VALUE;for(let s=0;s<v.faces.length;s++){c.copy(v.faceNormals[s]),i.vmult(c,c);const e=c.dot(t);e<M&&(M=e,y=s)}if(y<0)return;const b=v.faces[y];b.connectedFaces=[];for(let t=0;t<v.faces.length;t++)for(let s=0;s<v.faces[t].length;s++)-1!==b.indexOf(v.faces[t][s])&&t!==y&&-1===b.connectedFaces.indexOf(t)&&b.connectedFaces.push(t);const x=b.length;for(let t=0;t<x;t++){const e=v.vertices[b[t]];e.vsub(v.vertices[b[(t+1)%x]],l),a.copy(l),i.vmult(a,a),s.vadd(a,a),u.copy(this.faceNormals[y]),i.vmult(u,u),s.vadd(u,u),a.cross(u,w),w.negate(w),f.copy(e),i.vmult(f,f),s.vadd(f,f);const n=b.connectedFaces[t];d.copy(this.faceNormals[n]);const h=this.getPlaneConstantOfFace(n);p.copy(d),i.vmult(p,p);const o=h-p.dot(s);for(this.clipFaceAgainstPlane(g,m,p,o);g.length;)g.shift();for(;m.length;)g.push(m.shift())}d.copy(this.faceNormals[y]);const $=this.getPlaneConstantOfFace(y);p.copy(d),i.vmult(p,p);const A=$-p.dot(s);for(let t=0;t<g.length;t++){let s=p.dot(g[t])+A;if(s<=n&&(console.log(`clamped: depth=${s} to minDist=${n}`),s=n),s<=h){const i=g[t];s<=1e-6&&r.push({point:i,normal:p,depth:s})}}}clipFaceAgainstPlane(t,s,i,e){let n,h;const r=t.length;if(r<2)return s;let c=t[t.length-1],l=t[0];n=i.dot(c)+e;for(let a=0;a<r;a++){if(l=t[a],h=i.dot(l)+e,n<0)if(h<0){const t=new o;t.copy(l),s.push(t)}else{const t=new o;c.lerp(l,n/(n-h),t),s.push(t)}else if(h<0){const t=new o;c.lerp(l,n/(n-h),t),s.push(t),s.push(l)}c=l,n=h}return s}computeWorldVertices(t,s){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new o);const i=this.vertices,e=this.worldVertices;for(let n=0;n!==this.vertices.length;n++)s.vmult(i[n],e[n]),t.vadd(e[n],e[n]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,s){const i=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),s.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let e=0;e<this.vertices.length;e++){const n=i[e];n.x<t.x?t.x=n.x:n.x>s.x&&(s.x=n.x),n.y<t.y?t.y=n.y:n.y>s.y&&(s.y=n.y),n.z<t.z?t.z=n.z:n.z>s.z&&(s.z=n.z)}}computeWorldFaceNormals(t){const s=this.faceNormals.length;for(;this.worldFaceNormals.length<s;)this.worldFaceNormals.push(new o);const i=this.faceNormals,e=this.worldFaceNormals;for(let n=0;n!==s;n++)t.vmult(i[n],e[n]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const s=this.vertices;for(let i=0;i!==s.length;i++){const e=s[i].lengthSquared();e>t&&(t=e)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,s,i,e){const n=this.vertices;let h,r,c,l,a,u,w=new o;for(let i=0;i<n.length;i++){w.copy(n[i]),s.vmult(w,w),t.vadd(w,w);const e=w;(void 0===h||e.x<h)&&(h=e.x),(void 0===l||e.x>l)&&(l=e.x),(void 0===r||e.y<r)&&(r=e.y),(void 0===a||e.y>a)&&(a=e.y),(void 0===c||e.z<c)&&(c=e.z),(void 0===u||e.z>u)&&(u=e.z)}i.set(h,r,c),e.set(l,a,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){void 0===t&&(t=new o);const s=this.vertices;for(let i=0;i<s.length;i++)t.vadd(s[i],t);return t.scale(1/s.length,t),t}transformAllPoints(t,s){const i=this.vertices.length,e=this.vertices;if(s){for(let t=0;t<i;t++){const i=e[t];s.vmult(i,i)}for(let t=0;t<this.faceNormals.length;t++){const i=this.faceNormals[t];s.vmult(i,i)}}if(t)for(let s=0;s<i;s++){const i=e[s];i.vadd(t,i)}}pointIsInside(t){const s=this.vertices,i=this.faces,e=this.faceNormals,n=new o;this.getAveragePointLocal(n);for(let h=0;h<this.faces.length;h++){let r=e[h];const c=s[i[h][0]],l=new o;t.vsub(c,l);const a=r.dot(l),u=new o;n.vsub(c,u);const w=r.dot(u);if(a<0&&w>0||a>0&&w<0)return!1}return-1}static project(t,s,i,e,n){const h=t.vertices.length,o=A;let r=0,c=0;const l=B,a=t.vertices;l.setZero(),y.vectorToLocalFrame(i,e,s,o),y.pointToLocalFrame(i,e,l,l);const u=l.dot(o);c=r=a[0].dot(o);for(let t=1;t<h;t++){const s=a[t].dot(o);s>r&&(r=s),s<c&&(c=s)}if(c-=u,r-=u,c>r){const t=c;c=r,r=t}n[0]=r,n[1]=c}}const x=[],$=[];new o;const A=new o,B=new o;class k extends m{constructor(t){super({type:m.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,s=this.halfExtents.y,i=this.halfExtents.z,e=o,n=[new e(-t,-s,-i),new e(t,-s,-i),new e(t,s,-i),new e(-t,s,-i),new e(-t,-s,i),new e(t,-s,i),new e(t,s,i),new e(-t,s,i)],h=[new e(0,0,1),new e(0,1,0),new e(1,0,0)],r=new b({vertices:n,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:h});this.convexPolyhedronRepresentation=r,r.material=this.material}calculateLocalInertia(t,s){return void 0===s&&(s=new o),k.calculateInertia(this.halfExtents,t,s),s}static calculateInertia(t,s,i){const e=t;i.x=1/12*s*(2*e.y*2*e.y+2*e.z*2*e.z),i.y=1/12*s*(2*e.x*2*e.x+2*e.z*2*e.z),i.z=1/12*s*(2*e.y*2*e.y+2*e.x*2*e.x)}getSideNormals(t,s){const i=t,e=this.halfExtents;if(i[0].set(e.x,0,0),i[1].set(0,e.y,0),i[2].set(0,0,e.z),i[3].set(-e.x,0,0),i[4].set(0,-e.y,0),i[5].set(0,0,-e.z),void 0!==s)for(let t=0;t!==i.length;t++)s.vmult(i[t],i[t]);return i}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,s,i){const e=this.halfExtents,n=[[e.x,e.y,e.z],[-e.x,e.y,e.z],[-e.x,-e.y,e.z],[-e.x,-e.y,-e.z],[e.x,-e.y,-e.z],[e.x,e.y,-e.z],[-e.x,e.y,-e.z],[e.x,-e.y,e.z]];for(let e=0;e<n.length;e++)S.set(n[e][0],n[e][1],n[e][2]),s.vmult(S,S),t.vadd(S,S),i(S.x,S.y,S.z)}calculateWorldAABB(t,s,i,e){const n=this.halfExtents;C[0].set(n.x,n.y,n.z),C[1].set(-n.x,n.y,n.z),C[2].set(-n.x,-n.y,n.z),C[3].set(-n.x,-n.y,-n.z),C[4].set(n.x,-n.y,-n.z),C[5].set(n.x,n.y,-n.z),C[6].set(-n.x,n.y,-n.z),C[7].set(n.x,-n.y,n.z);const h=C[0];s.vmult(h,h),t.vadd(h,h),e.copy(h),i.copy(h);for(let n=1;n<8;n++){const h=C[n];s.vmult(h,h),t.vadd(h,h);const o=h.x,r=h.y,c=h.z;o>e.x&&(e.x=o),r>e.y&&(e.y=r),c>e.z&&(e.z=c),o<i.x&&(i.x=o),r<i.y&&(i.y=r),c<i.z&&(i.z=c)}}}const S=new o,C=[new o,new o,new o,new o,new o,new o,new o,new o];class F extends d{constructor(t){void 0===t&&(t={}),super(),this.id=F.idCounter++,this.index=-1,this.world=null,this.vlambda=new o,this.collisionFilterGroup="number"==typeof t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof t.collisionResponse||t.collisionResponse,this.position=new o,this.previousPosition=new o,this.interpolatedPosition=new o,this.initPosition=new o,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new o,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new o,this.force=new o;const s="number"==typeof t.mass?t.mass:0;this.mass=s,this.invMass=s>0?1/s:0,this.material=t.material||null,this.linearDamping="number"==typeof t.linearDamping?t.linearDamping:.01,this.type=s<=0?F.STATIC:F.DYNAMIC,typeof t.type==typeof F.STATIC&&(this.type=t.type),this.allowSleep=void 0===t.allowSleep||t.allowSleep,this.sleepState=F.AWAKE,this.sleepSpeedLimit=void 0!==t.sleepSpeedLimit?t.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==t.sleepTimeLimit?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new o,this.quaternion=new p,this.initQuaternion=new p,this.previousQuaternion=new p,this.interpolatedQuaternion=new p,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new o,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new o,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new o,this.invInertia=new o,this.invInertiaWorld=new n,this.invMassSolve=0,this.invInertiaSolve=new o,this.invInertiaWorldSolve=new n,this.fixedRotation=void 0!==t.fixedRotation&&t.fixedRotation,this.angularDamping=void 0!==t.angularDamping?t.angularDamping:.01,this.linearFactor=new o(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new o(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new a,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new o,this.isTrigger=Boolean(t.isTrigger),t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=F.AWAKE,this.wakeUpAfterNarrowphase=!1,t===F.SLEEPING&&this.dispatchEvent(F.wakeupEvent)}sleep(){this.sleepState=F.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const s=this.sleepState,i=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),e=this.sleepSpeedLimit**2;s===F.AWAKE&&i<e?(this.sleepState=F.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(F.sleepyEvent)):s===F.SLEEPY&&i>e?this.wakeUp():s===F.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(F.sleepEvent))}}updateSolveMassProperties(){this.sleepState===F.SLEEPING||this.type===F.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,s){return void 0===s&&(s=new o),t.vsub(this.position,s),this.quaternion.conjugate().vmult(s,s),s}vectorToLocalFrame(t,s){return void 0===s&&(s=new o),this.quaternion.conjugate().vmult(t,s),s}pointToWorldFrame(t,s){return void 0===s&&(s=new o),this.quaternion.vmult(t,s),s.vadd(this.position,s),s}vectorToWorldFrame(t,s){return void 0===s&&(s=new o),this.quaternion.vmult(t,s),s}addShape(t,s,i){const e=new o,n=new p;return s&&e.copy(s),i&&n.copy(i),this.shapes.push(t),this.shapeOffsets.push(e),this.shapeOrientations.push(n),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const s=this.shapes.indexOf(t);return-1===s?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(s,1),this.shapeOffsets.splice(s,1),this.shapeOrientations.splice(s,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,s=this.shapeOffsets,i=t.length;let e=0;for(let n=0;n!==i;n++){const i=t[n];i.updateBoundingSphereRadius();const h=s[n].length(),o=i.boundingSphereRadius;h+o>e&&(e=h+o)}this.boundingRadius=e}updateAABB(){const t=this.shapes,s=this.shapeOffsets,i=this.shapeOrientations,e=t.length,n=P,h=E,o=this.quaternion,r=this.aabb,c=T;for(let l=0;l!==e;l++){const e=t[l];o.vmult(s[l],n),n.vadd(this.position,n),o.mult(i[l],h),e.calculateWorldAABB(n,h,c.lowerBound,c.upperBound),0===l?r.copy(c):r.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const s=this.invInertia;if(s.x!==s.y||s.y!==s.z||t){const t=I,i=N;t.setRotationFromQuaternion(this.quaternion),t.transpose(i),t.scale(s,t),t.mmult(i,this.invInertiaWorld)}}applyForce(t,s){if(void 0===s&&(s=new o),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const i=_;s.cross(t,i),this.force.vadd(t,this.force),this.torque.vadd(i,this.torque)}applyLocalForce(t,s){if(void 0===s&&(s=new o),this.type!==F.DYNAMIC)return;const i=L,e=W;this.vectorToWorldFrame(t,i),this.vectorToWorldFrame(s,e),this.applyForce(i,e)}applyTorque(t){this.type===F.DYNAMIC&&(this.sleepState===F.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,s){if(void 0===s&&(s=new o),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const i=s,e=R;e.copy(t),e.scale(this.invMass,e),this.velocity.vadd(e,this.velocity);const n=q;i.cross(t,n),this.invInertiaWorld.vmult(n,n),this.angularVelocity.vadd(n,this.angularVelocity)}applyLocalImpulse(t,s){if(void 0===s&&(s=new o),this.type!==F.DYNAMIC)return;const i=Z,e=j;this.vectorToWorldFrame(t,i),this.vectorToWorldFrame(s,e),this.applyImpulse(i,e)}updateMassProperties(){const t=H;this.invMass=this.mass>0?1/this.mass:0;const s=this.inertia,i=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),k.calculateInertia(t,this.mass,s),this.invInertia.set(s.x>0&&!i?1/s.x:0,s.y>0&&!i?1/s.y:0,s.z>0&&!i?1/s.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,s){const i=new o;return t.vsub(this.position,i),this.angularVelocity.cross(i,s),this.velocity.vadd(s,s),s}integrate(t,s,i){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==F.DYNAMIC&&this.type!==F.KINEMATIC||this.sleepState===F.SLEEPING)return;const e=this.velocity,n=this.angularVelocity,h=this.position,o=this.force,r=this.torque,c=this.quaternion,l=this.invInertiaWorld,a=this.linearFactor,u=this.invMass*t;e.x+=o.x*u*a.x,e.y+=o.y*u*a.y,e.z+=o.z*u*a.z;const w=l.elements,f=this.angularFactor,d=r.x*f.x,p=r.y*f.y,v=r.z*f.z;n.x+=t*(w[0]*d+w[1]*p+w[2]*v),n.y+=t*(w[3]*d+w[4]*p+w[5]*v),n.z+=t*(w[6]*d+w[7]*p+w[8]*v),h.x+=e.x*t,h.y+=e.y*t,h.z+=e.z*t,c.integrate(this.angularVelocity,t,this.angularFactor,c),s&&(i?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}F.idCounter=0,F.COLLIDE_EVENT_NAME="collide",F.DYNAMIC=1,F.STATIC=2,F.KINEMATIC=4,F.AWAKE=0,F.SLEEPY=1,F.SLEEPING=2,F.wakeupEvent={type:"wakeup"},F.sleepyEvent={type:"sleepy"},F.sleepEvent={type:"sleep"};const P=new o,E=new p,T=new a,I=new n,N=new n;new n;const _=new o,L=new o,W=new o,R=new o,q=new o,Z=new o,j=new o,H=new o,O=new o;new o,new p,new o;const U={keys:[]},D=[],G=[];new o,new o,new o;class z extends class{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,s,i){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,s){return 0!=(t.collisionFilterGroup&s.collisionFilterMask)&&0!=(s.collisionFilterGroup&t.collisionFilterMask)&&(0==(t.type&F.STATIC)&&t.sleepState!==F.SLEEPING||0==(s.type&F.STATIC)&&s.sleepState!==F.SLEEPING)}intersectionTest(t,s,i,e){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,s,i,e):this.doBoundingSphereBroadphase(t,s,i,e)}doBoundingSphereBroadphase(t,s,i,e){const n=O;s.position.vsub(t.position,n);const h=(t.boundingRadius+s.boundingRadius)**2;n.lengthSquared()<h&&(i.push(t),e.push(s))}doBoundingBoxBroadphase(t,s,i,e){t.aabbNeedsUpdate&&t.updateAABB(),s.aabbNeedsUpdate&&s.updateAABB(),t.aabb.overlaps(s.aabb)&&(i.push(t),e.push(s))}makePairsUnique(t,s){const i=U,e=D,n=G,h=t.length;for(let i=0;i!==h;i++)e[i]=t[i],n[i]=s[i];t.length=0,s.length=0;for(let t=0;t!==h;t++){const s=e[t].id,h=n[t].id,o=s<h?`${s},${h}`:`${h},${s}`;i[o]=t,i.keys.push(o)}for(let h=0;h!==i.keys.length;h++){const h=i.keys.pop(),o=i[h];t.push(e[o]),s.push(n[o]),delete i[h]}}setWorld(t){}static boundingSphereCheck(t,s){const i=new o;return t.position.vsub(s.position,i),Math.pow(t.shapes[0].boundingSphereRadius+s.shapes[0].boundingSphereRadius,2)>i.lengthSquared()}aabbQuery(t,s,i){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}{constructor(){super()}collisionPairs(t,s,i){const e=t.bodies,n=e.length;let h,o;for(let t=0;t!==n;t++)for(let n=0;n!==t;n++)h=e[t],o=e[n],this.needBroadphaseCollision(h,o)&&this.intersectionTest(h,o,s,i)}aabbQuery(t,s,i){void 0===i&&(i=[]);for(let e=0;e<t.bodies.length;e++){const n=t.bodies[e];n.aabbNeedsUpdate&&n.updateAABB(),n.aabb.overlaps(s)&&i.push(n)}return i}}class X{constructor(){this.rayFromWorld=new o,this.rayToWorld=new o,this.hitNormalWorld=new o,this.hitPointWorld=new o,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,s,i,e,n,h,o){this.rayFromWorld.copy(t),this.rayToWorld.copy(s),this.hitNormalWorld.copy(i),this.hitPointWorld.copy(e),this.shape=n,this.body=h,this.distance=o}}let Y,V,Q,K,J,tt,st;Y=m.types.SPHERE,V=m.types.PLANE,Q=m.types.BOX,K=m.types.CYLINDER,J=m.types.CONVEXPOLYHEDRON,tt=m.types.HEIGHTFIELD,st=m.types.TRIMESH;class it{get[Y](){return this._intersectSphere}get[V](){return this._intersectPlane}get[Q](){return this._intersectBox}get[K](){return this._intersectConvex}get[J](){return this._intersectConvex}get[tt](){return this._intersectHeightfield}get[st](){return this._intersectTrimesh}constructor(t,s){void 0===t&&(t=new o),void 0===s&&(s=new o),this.from=t.clone(),this.to=s.clone(),this.direction=new o,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=it.ANY,this.result=new X,this.hasHit=!1,this.callback=()=>{}}intersectWorld(t,s){return this.mode=s.mode||it.ANY,this.result=s.result||new X,this.skipBackfaces=!!s.skipBackfaces,this.collisionFilterMask=void 0!==s.collisionFilterMask?s.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==s.collisionFilterGroup?s.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===s.checkCollisionResponse||s.checkCollisionResponse,s.from&&this.from.copy(s.from),s.to&&this.to.copy(s.to),this.callback=s.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(et),nt.length=0,t.broadphase.aabbQuery(t,et,nt),this.intersectBodies(nt),this.hasHit}intersectBody(t,s){s&&(this.result=s,this.updateDirection());const i=this.checkCollisionResponse;if(i&&!t.collisionResponse)return;if(0==(this.collisionFilterGroup&t.collisionFilterMask)||0==(t.collisionFilterGroup&this.collisionFilterMask))return;const e=rt,n=ct;for(let s=0,h=t.shapes.length;s<h;s++){const h=t.shapes[s];if((!i||h.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[s],n),t.quaternion.vmult(t.shapeOffsets[s],e),e.vadd(t.position,e),this.intersectShape(h,n,e,t),this.result.shouldStop))break}}intersectBodies(t,s){s&&(this.result=s,this.updateDirection());for(let s=0,i=t.length;!this.result.shouldStop&&s<i;s++)this.intersectBody(t[s])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,s,i,e){if(function(t,s,i){i.vsub(t,Ft);const e=Ft.dot(s);return s.scale(e,Pt),Pt.vadd(t,Pt),i.distanceTo(Pt)}(this.from,this.direction,i)>t.boundingSphereRadius)return;const n=this[t.type];n&&n.call(this,t,s,i,e,t)}_intersectBox(t,s,i,e,n){return this._intersectConvex(t.convexPolyhedronRepresentation,s,i,e,n)}_intersectPlane(t,s,i,e,n){const h=this.from,r=this.to,c=this.direction,l=new o(0,0,1);s.vmult(l,l);const a=new o;h.vsub(i,a);const u=a.dot(l);if(r.vsub(i,a),u*a.dot(l)>0)return;if(h.distanceTo(r)<u)return;const w=l.dot(c);if(Math.abs(w)<this.precision)return;const f=new o,d=new o,p=new o;h.vsub(i,f);const v=-l.dot(f)/w;c.scale(v,d),h.vadd(d,p),this.reportIntersection(l,p,n,e,-1)}getAABB(t){const{lowerBound:s,upperBound:i}=t,e=this.to,n=this.from;s.x=Math.min(e.x,n.x),s.y=Math.min(e.y,n.y),s.z=Math.min(e.z,n.z),i.x=Math.max(e.x,n.x),i.y=Math.max(e.y,n.y),i.z=Math.max(e.z,n.z)}_intersectHeightfield(t,s,i,e,n){const h=pt;h.from.copy(this.from),h.to.copy(this.to),y.pointToLocalFrame(i,s,h.from,h.from),y.pointToLocalFrame(i,s,h.to,h.to),h.updateDirection();const o=vt;let r,c,l,u;r=c=0,l=u=t.data.length-1;const w=new a;h.getAABB(w),t.getIndexOfPosition(w.lowerBound.x,w.lowerBound.y,o,!0),r=Math.max(r,o[0]),c=Math.max(c,o[1]),t.getIndexOfPosition(w.upperBound.x,w.upperBound.y,o,!0),l=Math.min(l,o[0]+1),u=Math.min(u,o[1]+1);for(let o=r;o<l;o++)for(let r=c;r<u;r++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(o,r,w),w.overlapsRay(h)){if(t.getConvexTrianglePillar(o,r,!1),y.pointToWorldFrame(i,s,t.pillarOffset,dt),this._intersectConvex(t.pillarConvex,s,dt,e,n,ft),this.result.shouldStop)return;t.getConvexTrianglePillar(o,r,!0),y.pointToWorldFrame(i,s,t.pillarOffset,dt),this._intersectConvex(t.pillarConvex,s,dt,e,n,ft)}}}_intersectSphere(t,s,i,e,n){const h=this.from,o=this.to,r=(o.x-h.x)**2+(o.y-h.y)**2+(o.z-h.z)**2,c=2*((o.x-h.x)*(h.x-i.x)+(o.y-h.y)*(h.y-i.y)+(o.z-h.z)*(h.z-i.z)),l=c**2-4*r*((h.x-i.x)**2+(h.y-i.y)**2+(h.z-i.z)**2-t.radius**2),a=gt,u=mt;if(!(l<0))if(0===l)h.lerp(o,l,a),a.vsub(i,u),u.normalize(),this.reportIntersection(u,a,n,e,-1);else{const t=(-c-Math.sqrt(l))/(2*r),s=(-c+Math.sqrt(l))/(2*r);if(t>=0&&t<=1&&(h.lerp(o,t,a),a.vsub(i,u),u.normalize(),this.reportIntersection(u,a,n,e,-1)),this.result.shouldStop)return;s>=0&&s<=1&&(h.lerp(o,s,a),a.vsub(i,u),u.normalize(),this.reportIntersection(u,a,n,e,-1))}}_intersectConvex(t,s,i,e,n,h){const o=yt,r=Mt,c=h&&h.faceList||null,l=t.faces,a=t.vertices,u=t.faceNormals,w=this.direction,f=this.from,d=f.distanceTo(this.to),p=c?c.length:l.length,v=this.result;for(let t=0;!v.shouldStop&&t<p;t++){const h=c?c[t]:t,p=l[h],g=u[h],m=s,y=i;r.copy(a[p[0]]),m.vmult(r,r),r.vadd(y,r),r.vsub(f,r),m.vmult(g,o);const M=w.dot(o);if(Math.abs(M)<this.precision)continue;const b=o.dot(r)/M;if(!(b<0)){w.scale(b,lt),lt.vadd(f,lt),at.copy(a[p[0]]),m.vmult(at,at),y.vadd(at,at);for(let t=1;!v.shouldStop&&t<p.length-1;t++){ut.copy(a[p[t]]),wt.copy(a[p[t+1]]),m.vmult(ut,ut),m.vmult(wt,wt),y.vadd(ut,ut),y.vadd(wt,wt);const s=lt.distanceTo(f);!it.pointInTriangle(lt,at,ut,wt)&&!it.pointInTriangle(lt,ut,at,wt)||s>d||this.reportIntersection(o,lt,n,e,h)}}}}_intersectTrimesh(t,s,i,e,n,h){const o=bt,r=St,c=Ct,l=Mt,a=xt,u=$t,w=At,f=kt,d=Bt,p=t.indices,v=this.from,g=this.to,m=this.direction;c.position.copy(i),c.quaternion.copy(s),y.vectorToLocalFrame(i,s,m,a),y.pointToLocalFrame(i,s,v,u),y.pointToLocalFrame(i,s,g,w),w.x*=t.scale.x,w.y*=t.scale.y,w.z*=t.scale.z,u.x*=t.scale.x,u.y*=t.scale.y,u.z*=t.scale.z,w.vsub(u,a),a.normalize();const M=u.distanceSquared(w);t.tree.rayQuery(this,c,r);for(let h=0,c=r.length;!this.result.shouldStop&&h!==c;h++){const c=r[h];t.getNormal(c,o),t.getVertex(p[3*c],at),at.vsub(u,l);const w=a.dot(o),v=o.dot(l)/w;if(v<0)continue;a.scale(v,lt),lt.vadd(u,lt),t.getVertex(p[3*c+1],ut),t.getVertex(p[3*c+2],wt);const g=lt.distanceSquared(u);!it.pointInTriangle(lt,ut,at,wt)&&!it.pointInTriangle(lt,at,ut,wt)||g>M||(y.vectorToWorldFrame(s,o,d),y.pointToWorldFrame(i,s,lt,f),this.reportIntersection(d,f,n,e,c))}r.length=0}reportIntersection(t,s,i,e,n){const h=this.from,o=this.to,r=h.distanceTo(s),c=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(c.hitFaceIndex=void 0!==n?n:-1,this.mode){case it.ALL:this.hasHit=!0,c.set(h,o,t,s,i,e,r),c.hasHit=!0,this.callback(c);break;case it.CLOSEST:(r<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(h,o,t,s,i,e,r));break;case it.ANY:this.hasHit=!0,c.hasHit=!0,c.set(h,o,t,s,i,e,r),c.shouldStop=!0}}static pointInTriangle(t,s,i,e){e.vsub(s,Ft),i.vsub(s,ht),t.vsub(s,ot);const n=Ft.dot(Ft),h=Ft.dot(ht),o=Ft.dot(ot),r=ht.dot(ht),c=ht.dot(ot);let l,a;return(l=r*o-h*c)>=0&&(a=n*c-h*o)>=0&&l+a<n*r-h*h}}it.CLOSEST=1,it.ANY=2,it.ALL=4;const et=new a,nt=[],ht=new o,ot=new o,rt=new o,ct=new p,lt=new o,at=new o,ut=new o,wt=new o;new o,new X;const ft={faceList:[0]},dt=new o,pt=new it,vt=[],gt=new o,mt=new o,yt=new o;new o,new o;const Mt=new o,bt=new o,xt=new o,$t=new o,At=new o,Bt=new o,kt=new o;new a;const St=[],Ct=new y,Ft=new o,Pt=new o;class Et{constructor(){this.spatial=new o,this.rotational=new o}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,s){return t.dot(this.spatial)+s.dot(this.rotational)}}class Tt{constructor(t,s,i,e){void 0===i&&(i=-1e6),void 0===e&&(e=1e6),this.id=Tt.idCounter++,this.minForce=i,this.maxForce=e,this.bi=t,this.bj=s,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Et,this.jacobianElementB=new Et,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,s,i){const e=s,n=t,h=i;this.a=4/(h*(1+4*e)),this.b=4*e/(1+4*e),this.eps=4/(h*h*n*(1+4*e))}computeB(t,s,i){const e=this.computeGW();return-this.computeGq()*t-e*s-this.computeGiMf()*i}computeGq(){const t=this.jacobianElementB,s=this.bj.position;return this.jacobianElementA.spatial.dot(this.bi.position)+t.spatial.dot(s)}computeGW(){const t=this.jacobianElementB,s=this.bi,i=this.bj,e=i.velocity,n=i.angularVelocity;return this.jacobianElementA.multiplyVectors(s.velocity,s.angularVelocity)+t.multiplyVectors(e,n)}computeGWlambda(){const t=this.jacobianElementB,s=this.bi,i=this.bj,e=i.vlambda,n=i.wlambda;return this.jacobianElementA.multiplyVectors(s.vlambda,s.wlambda)+t.multiplyVectors(e,n)}computeGiMf(){const t=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,e=this.bj,n=i.torque,h=e.force,o=e.torque,r=e.invMassSolve;return i.force.scale(i.invMassSolve,It),h.scale(r,Nt),i.invInertiaWorldSolve.vmult(n,_t),e.invInertiaWorldSolve.vmult(o,Lt),t.multiplyVectors(It,_t)+s.multiplyVectors(Nt,Lt)}computeGiMGt(){const t=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,e=this.bj,n=e.invInertiaWorldSolve;let h=i.invMassSolve+e.invMassSolve;return i.invInertiaWorldSolve.vmult(t.rotational,Wt),h+=Wt.dot(t.rotational),n.vmult(s.rotational,Wt),h+=Wt.dot(s.rotational),h}addToWlambda(t){const s=this.jacobianElementA,i=this.jacobianElementB,e=this.bi,n=this.bj,h=Rt;e.vlambda.addScaledVector(e.invMassSolve*t,s.spatial,e.vlambda),n.vlambda.addScaledVector(n.invMassSolve*t,i.spatial,n.vlambda),e.invInertiaWorldSolve.vmult(s.rotational,h),e.wlambda.addScaledVector(t,h,e.wlambda),n.invInertiaWorldSolve.vmult(i.rotational,h),n.wlambda.addScaledVector(t,h,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Tt.idCounter=0;const It=new o,Nt=new o,_t=new o,Lt=new o,Wt=new o,Rt=new o;class qt extends Tt{constructor(t,s,i){void 0===i&&(i=1e6),super(t,s,0,i),this.restitution=0,this.ri=new o,this.rj=new o,this.ni=new o}computeB(t){const s=this.a,i=this.b,e=this.bi,n=this.bj,h=this.ri,o=this.rj,r=Zt,c=jt,l=e.velocity,a=e.angularVelocity,u=n.velocity,w=n.angularVelocity,f=Ht,d=this.jacobianElementA,p=this.jacobianElementB,v=this.ni;h.cross(v,r),o.cross(v,c),v.negate(d.spatial),r.negate(d.rotational),p.spatial.copy(v),p.rotational.copy(c),f.copy(n.position),f.vadd(o,f),f.vsub(e.position,f),f.vsub(h,f);const g=v.dot(f),m=this.restitution+1;return-g*s-(m*u.dot(v)-m*l.dot(v)+w.dot(c)-a.dot(r))*i-t*this.computeGiMf()}getImpactVelocityAlongNormal(){const t=Ot,s=Ut,i=Dt,e=Gt,n=zt;return this.bi.position.vadd(this.ri,i),this.bj.position.vadd(this.rj,e),this.bi.getVelocityAtWorldPoint(i,t),this.bj.getVelocityAtWorldPoint(e,s),t.vsub(s,n),this.ni.dot(n)}}const Zt=new o,jt=new o,Ht=new o,Ot=new o,Ut=new o,Dt=new o,Gt=new o,zt=new o;new o,new o,new o,new o,new o,new o,new o,new o,new o,new o;class Xt extends Tt{constructor(t,s,i){super(t,s,-i,i),this.ri=new o,this.rj=new o,this.t=new o}computeB(t){const s=this.b,i=this.rj,e=Yt,n=Vt,h=this.t;this.ri.cross(h,e),i.cross(h,n);const o=this.jacobianElementA,r=this.jacobianElementB;return h.negate(o.spatial),e.negate(o.rotational),r.spatial.copy(h),r.rotational.copy(n),-this.computeGW()*s-t*this.computeGiMf()}}const Yt=new o,Vt=new o;class Qt{constructor(t,s,i){i=class{static defaults(t,s){void 0===t&&(t={});for(let i in s)i in t||(t[i]=s[i]);return t}}.defaults(i,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Qt.idCounter++,this.materials=[t,s],this.friction=i.friction,this.restitution=i.restitution,this.contactEquationStiffness=i.contactEquationStiffness,this.contactEquationRelaxation=i.contactEquationRelaxation,this.frictionEquationStiffness=i.frictionEquationStiffness,this.frictionEquationRelaxation=i.frictionEquationRelaxation}}Qt.idCounter=0;class Kt{constructor(t){void 0===t&&(t={});let s="";"string"==typeof t&&(s=t,t={}),this.name=s,this.id=Kt.idCounter++,this.friction=void 0!==t.friction?t.friction:-1,this.restitution=void 0!==t.restitution?t.restitution:-1}}Kt.idCounter=0,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new it,new o,new o,new o,new o(1,0,0),new o(0,1,0),new o(0,0,1),new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new o;class Jt extends m{constructor(t){if(super({type:m.types.SPHERE}),this.radius=void 0!==t?t:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,s){void 0===s&&(s=new o);const i=2*t*this.radius*this.radius/5;return s.x=i,s.y=i,s.z=i,s}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,s,i,e){const n=this.radius,h=["x","y","z"];for(let s=0;s<h.length;s++){const o=h[s];i[o]=t[o]-n,e[o]=t[o]+n}}}new o,new o,new o,new o,new o,new o,new o,new o,new o;class ts extends m{constructor(){super({type:m.types.PLANE}),this.worldNormal=new o,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){const s=this.worldNormal;s.set(0,0,1),t.vmult(s,s),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,s){return void 0===s&&(s=new o),s}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,s,i,e){ss.set(0,0,1),s.vmult(ss,ss);const n=Number.MAX_VALUE;i.set(-n,-n,-n),e.set(n,n,n),1===ss.x?e.x=t.x:-1===ss.x&&(i.x=t.x),1===ss.y?e.y=t.y:-1===ss.y&&(i.y=t.y),1===ss.z?e.z=t.z:-1===ss.z&&(i.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const ss=new o;new o,new o,new o,new o,new o,new o,new o,new o,new o,new o,new a,new o,new a,new o,new o,new o,new o,new o,new o,new o,new a,new o,new y,new a;class is extends class{constructor(){this.equations=[]}solve(t,s){return 0}addEquation(t){!t.enabled||t.bi.isTrigger||t.bj.isTrigger||this.equations.push(t)}removeEquation(t){const s=this.equations,i=s.indexOf(t);-1!==i&&s.splice(i,1)}removeAllEquations(){this.equations.length=0}}{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,s){let i=0;const e=this.iterations,n=this.tolerance*this.tolerance,h=this.equations,o=h.length,r=s.bodies,c=r.length,l=t;let a,u,w,f,d,p;if(0!==o)for(let t=0;t!==c;t++)r[t].updateSolveMassProperties();const v=ns,g=hs,m=es;v.length=o,g.length=o,m.length=o;for(let t=0;t!==o;t++){const s=h[t];m[t]=0,g[t]=s.computeB(l),v[t]=1/s.computeC()}if(0!==o){for(let t=0;t!==c;t++){const s=r[t],i=s.wlambda;s.vlambda.set(0,0,0),i.set(0,0,0)}for(i=0;i!==e;i++){f=0;for(let t=0;t!==o;t++){const s=h[t];a=g[t],u=v[t],p=m[t],d=s.computeGWlambda(),w=u*(a-d-s.eps*p),p+w<s.minForce?w=s.minForce-p:p+w>s.maxForce&&(w=s.maxForce-p),m[t]+=w,f+=w>0?w:-w,s.addToWlambda(w)}if(f*f<n)break}for(let t=0;t!==c;t++){const s=r[t],i=s.velocity,e=s.angularVelocity;s.vlambda.vmul(s.linearFactor,s.vlambda),i.vadd(s.vlambda,i),s.wlambda.vmul(s.angularFactor,s.wlambda),e.vadd(s.wlambda,e)}let t=h.length;const s=1/l;for(;t--;)h[t].multiplier=m[t]*s}return i}}const es=[],ns=[],hs=[];class os extends class{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let s=0;s!==t;s++)this.objects.push(s<0||arguments.length<=s?void 0:arguments[s]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const s=this.objects;for(;s.length>t;)s.pop();for(;s.length<t;)s.push(this.constructObject());return this}}{constructor(){super(...arguments),this.type=o}constructObject(){return new o}}const rs=m.types.SPHERE,cs=m.types.SPHERE|m.types.PLANE,ls=m.types.BOX|m.types.BOX,as=m.types.SPHERE|m.types.BOX,us=m.types.PLANE|m.types.BOX,ws=m.types.CONVEXPOLYHEDRON,fs=m.types.SPHERE|m.types.CONVEXPOLYHEDRON,ds=m.types.PLANE|m.types.CONVEXPOLYHEDRON,ps=m.types.BOX|m.types.CONVEXPOLYHEDRON,vs=m.types.SPHERE|m.types.HEIGHTFIELD,gs=m.types.BOX|m.types.HEIGHTFIELD,ms=m.types.CONVEXPOLYHEDRON|m.types.HEIGHTFIELD,ys=m.types.PARTICLE|m.types.SPHERE,Ms=m.types.PLANE|m.types.PARTICLE,bs=m.types.BOX|m.types.PARTICLE,xs=m.types.PARTICLE|m.types.CONVEXPOLYHEDRON,$s=m.types.CYLINDER,As=m.types.SPHERE|m.types.CYLINDER,Bs=m.types.PLANE|m.types.CYLINDER,ks=m.types.BOX|m.types.CYLINDER,Ss=m.types.CONVEXPOLYHEDRON|m.types.CYLINDER,Cs=m.types.HEIGHTFIELD|m.types.CYLINDER,Fs=m.types.PARTICLE|m.types.CYLINDER,Ps=m.types.SPHERE|m.types.TRIMESH,Es=m.types.PLANE|m.types.TRIMESH;class Ts{get[rs](){return this.sphereSphere}get[cs](){return this.spherePlane}get[ls](){return this.boxBox}get[as](){return this.sphereBox}get[us](){return this.planeBox}get[ws](){return this.convexConvex}get[fs](){return this.sphereConvex}get[ds](){return this.planeConvex}get[ps](){return this.boxConvex}get[vs](){return this.sphereHeightfield}get[gs](){return this.boxHeightfield}get[ms](){return this.convexHeightfield}get[ys](){return this.sphereParticle}get[Ms](){return this.planeParticle}get[bs](){return this.boxParticle}get[xs](){return this.convexParticle}get[$s](){return this.convexConvex}get[As](){return this.sphereConvex}get[Bs](){return this.planeConvex}get[ks](){return this.boxConvex}get[Ss](){return this.convexConvex}get[Cs](){return this.heightfieldCylinder}get[Fs](){return this.particleCylinder}get[Ps](){return this.sphereTrimesh}get[Es](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new os,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,s,i,e,n,h){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=t,o.bj=s):o=new qt(t,s),o.enabled=t.collisionResponse&&s.collisionResponse&&i.collisionResponse&&e.collisionResponse;const r=this.currentContactMaterial;o.restitution=r.restitution,o.setSpookParams(r.contactEquationStiffness,r.contactEquationRelaxation,this.world.dt);const c=i.material||t.material,l=e.material||s.material;return c&&l&&c.restitution>=0&&l.restitution>=0&&(o.restitution=c.restitution*l.restitution),o.si=n||i,o.sj=h||e,o}createFrictionEquationsFromContact(t,s){const i=t.bi,e=t.bj,n=this.world,h=this.currentContactMaterial;let o=h.friction;const r=t.si.material||i.material,c=t.sj.material||e.material;if(r&&c&&r.friction>=0&&c.friction>=0&&(o=r.friction*c.friction),o>0){const r=o*n.gravity.length();let c=i.invMass+e.invMass;c>0&&(c=1/c);const l=this.frictionEquationPool,a=l.length?l.pop():new Xt(i,e,r*c),u=l.length?l.pop():new Xt(i,e,r*c);return a.bi=u.bi=i,a.bj=u.bj=e,a.minForce=u.minForce=-r*c,a.maxForce=u.maxForce=r*c,a.ri.copy(t.ri),a.rj.copy(t.rj),u.ri.copy(t.ri),u.rj.copy(t.rj),t.ni.tangents(a.t,u.t),a.setSpookParams(h.frictionEquationStiffness,h.frictionEquationRelaxation,n.dt),u.setSpookParams(h.frictionEquationStiffness,h.frictionEquationRelaxation,n.dt),a.enabled=u.enabled=t.enabled,s.push(a,u),!0}return!1}createFrictionFromAverage(t){let s=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(s,this.frictionResult)||1===t)return;const i=this.frictionResult[this.frictionResult.length-2],e=this.frictionResult[this.frictionResult.length-1];Is.setZero(),Ns.setZero(),_s.setZero();const n=s.bi;for(let i=0;i!==t;i++)s=this.result[this.result.length-1-i],s.bi!==n?(Is.vadd(s.ni,Is),Ns.vadd(s.ri,Ns),_s.vadd(s.rj,_s)):(Is.vsub(s.ni,Is),Ns.vadd(s.rj,Ns),_s.vadd(s.ri,_s));const h=1/t;Ns.scale(h,i.ri),_s.scale(h,i.rj),e.ri.copy(i.ri),e.rj.copy(i.rj),Is.normalize(),Is.tangents(i.t,e.t)}getContacts(t,s,i,e,n,h,o){this.contactPointPool=n,this.frictionEquationPool=o,this.result=e,this.frictionResult=h;const r=Rs,c=qs,l=Ls,a=Ws;for(let e=0,n=t.length;e!==n;e++){const n=t[e],h=s[e];let o=null;n.material&&h.material&&(o=i.getContactMaterial(n.material,h.material)||null);const u=n.type&F.KINEMATIC&&h.type&F.STATIC||n.type&F.STATIC&&h.type&F.KINEMATIC||n.type&F.KINEMATIC&&h.type&F.KINEMATIC;for(let t=0;t<n.shapes.length;t++){n.quaternion.mult(n.shapeOrientations[t],r),n.quaternion.vmult(n.shapeOffsets[t],l),l.vadd(n.position,l);const s=n.shapes[t];for(let t=0;t<h.shapes.length;t++){h.quaternion.mult(h.shapeOrientations[t],c),h.quaternion.vmult(h.shapeOffsets[t],a),a.vadd(h.position,a);const e=h.shapes[t];if(!(s.collisionFilterMask&e.collisionFilterGroup&&e.collisionFilterMask&s.collisionFilterGroup))continue;if(l.distanceTo(a)>s.boundingSphereRadius+e.boundingSphereRadius)continue;let w=null;s.material&&e.material&&(w=i.getContactMaterial(s.material,e.material)||null),this.currentContactMaterial=w||o||i.defaultContactMaterial;const f=this[s.type|e.type];if(f){let t=!1;t=s.type<e.type?f.call(this,s,e,l,a,r,c,n,h,s,e,u):f.call(this,e,s,a,l,c,r,h,n,s,e,u),t&&u&&(i.shapeOverlapKeeper.set(s.id,e.id),i.bodyOverlapKeeper.set(n.id,h.id))}}}}}sphereSphere(t,s,i,e,n,h,o,r,c,l,a){if(a)return i.distanceSquared(e)<(t.radius+s.radius)**2;const u=this.createContactEquation(o,r,t,s,c,l);e.vsub(i,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.scale(t.radius,u.ri),u.rj.scale(-s.radius,u.rj),u.ri.vadd(i,u.ri),u.ri.vsub(o.position,u.ri),u.rj.vadd(e,u.rj),u.rj.vsub(r.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}spherePlane(t,s,i,e,n,h,o,r,c,l,a){const u=this.createContactEquation(o,r,t,s,c,l);if(u.ni.set(0,0,1),h.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.scale(t.radius,u.ri),i.vsub(e,ni),u.ni.scale(u.ni.dot(ni),hi),ni.vsub(hi,u.rj),-ni.dot(u.ni)<=t.radius){if(a)return!0;const t=u.ri,s=u.rj;t.vadd(i,t),t.vsub(o.position,t),s.vadd(e,s),s.vsub(r.position,s),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}}boxBox(t,s,i,e,n,h,o,r,c,l,a){return t.convexPolyhedronRepresentation.material=t.material,s.convexPolyhedronRepresentation.material=s.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,s.convexPolyhedronRepresentation.collisionResponse=s.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,s.convexPolyhedronRepresentation,i,e,n,h,o,r,t,s,a)}sphereBox(t,s,i,e,n,h,o,r,c,l,a){const u=this.v3pool,w=di;i.vsub(e,ai),s.getSideNormals(w,h);const f=t.radius;let d=!1;const p=vi,v=gi,g=mi;let m=null,y=0,M=0,b=0,x=null;for(let t=0,s=w.length;t!==s&&!1===d;t++){const s=ui;s.copy(w[t]);const i=s.length();s.normalize();const e=ai.dot(s);if(e<i+f&&e>0){const n=wi,h=fi;n.copy(w[(t+1)%3]),h.copy(w[(t+2)%3]);const o=n.length(),r=h.length();n.normalize(),h.normalize();const c=ai.dot(n),l=ai.dot(h);if(c<o&&c>-o&&l<r&&l>-r){const t=Math.abs(e-i-f);if((null===x||t<x)&&(x=t,M=c,b=l,m=i,p.copy(s),v.copy(n),g.copy(h),y++,a))return!0}}}if(y){d=!0;const n=this.createContactEquation(o,r,t,s,c,l);p.scale(-f,n.ri),n.ni.copy(p),n.ni.negate(n.ni),p.scale(m,p),v.scale(M,v),p.vadd(v,p),g.scale(b,g),p.vadd(g,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),n.rj.vadd(e,n.rj),n.rj.vsub(r.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}let $=u.get();const A=pi;for(let n=0;2!==n&&!d;n++)for(let h=0;2!==h&&!d;h++)for(let u=0;2!==u&&!d;u++)if($.set(0,0,0),n?$.vadd(w[0],$):$.vsub(w[0],$),h?$.vadd(w[1],$):$.vsub(w[1],$),u?$.vadd(w[2],$):$.vsub(w[2],$),e.vadd($,A),A.vsub(i,A),A.lengthSquared()<f*f){if(a)return!0;d=!0;const n=this.createContactEquation(o,r,t,s,c,l);n.ri.copy(A),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(f,n.ri),n.rj.copy($),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),n.rj.vadd(e,n.rj),n.rj.vsub(r.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}u.release($),$=null;const B=u.get(),k=u.get(),S=u.get(),C=u.get(),F=u.get(),P=w.length;for(let n=0;n!==P&&!d;n++)for(let h=0;h!==P&&!d;h++)if(n%3!=h%3){w[h].cross(w[n],B),B.normalize(),w[n].vadd(w[h],k),S.copy(i),S.vsub(k,S),S.vsub(e,S);const u=S.dot(B);B.scale(u,C);let p=0;for(;p===n%3||p===h%3;)p++;F.copy(i),F.vsub(C,F),F.vsub(k,F),F.vsub(e,F);const v=Math.abs(u),g=F.length();if(v<w[p].length()&&g<f){if(a)return!0;d=!0;const n=this.createContactEquation(o,r,t,s,c,l);k.vadd(C,n.rj),n.rj.copy(n.rj),F.negate(n.ni),n.ni.normalize(),n.ri.copy(n.rj),n.ri.vadd(e,n.ri),n.ri.vsub(i,n.ri),n.ri.normalize(),n.ri.scale(f,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),n.rj.vadd(e,n.rj),n.rj.vsub(r.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}u.release(B,k,S,C,F)}planeBox(t,s,i,e,n,h,o,r,c,l,a){return s.convexPolyhedronRepresentation.material=s.material,s.convexPolyhedronRepresentation.collisionResponse=s.collisionResponse,s.convexPolyhedronRepresentation.id=s.id,this.planeConvex(t,s.convexPolyhedronRepresentation,i,e,n,h,o,r,t,s,a)}convexConvex(t,s,i,e,n,h,o,r,c,l,a,u,w){const f=Ii;if(!(i.distanceTo(e)>t.boundingSphereRadius+s.boundingSphereRadius)&&t.findSeparatingAxis(s,i,n,e,h,f,u,w)){const u=[],w=Ni;t.clipAgainstHull(i,n,s,e,h,f,-100,100,u);let d=0;for(let n=0;n!==u.length;n++){if(a)return!0;const h=this.createContactEquation(o,r,t,s,c,l),p=h.ri,v=h.rj;f.negate(h.ni),u[n].normal.negate(w),w.scale(u[n].depth,w),u[n].point.vadd(w,p),v.copy(u[n].point),p.vsub(i,p),v.vsub(e,v),p.vadd(i,p),p.vsub(o.position,p),v.vadd(e,v),v.vsub(r.position,v),this.result.push(h),d++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(h,this.frictionResult)}this.enableFrictionReduction&&d&&this.createFrictionFromAverage(d)}}sphereConvex(t,s,i,e,n,h,o,r,c,l,a){const u=this.v3pool;i.vsub(e,yi);const w=s.faceNormals,f=s.faces,d=s.vertices,p=t.radius;let v=!1;for(let n=0;n!==d.length;n++){const u=$i;h.vmult(d[n],u),e.vadd(u,u);const w=xi;if(u.vsub(i,w),w.lengthSquared()<p*p){if(a)return!0;v=!0;const n=this.createContactEquation(o,r,t,s,c,l);return n.ri.copy(w),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(p,n.ri),u.vsub(e,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),n.rj.vadd(e,n.rj),n.rj.vsub(r.position,n.rj),this.result.push(n),void this.createFrictionEquationsFromContact(n,this.frictionResult)}}for(let n=0,g=f.length;n!==g&&!1===v;n++){const g=f[n],m=Ai;h.vmult(w[n],m);const y=Bi;h.vmult(d[g[0]],y),y.vadd(e,y);const M=ki;m.scale(-p,M),i.vadd(M,M);const b=Si;M.vsub(y,b);const x=b.dot(m),$=Ci;if(i.vsub(y,$),x<0&&$.dot(m)>0){const n=[];for(let t=0,s=g.length;t!==s;t++){const s=u.get();h.vmult(d[g[t]],s),e.vadd(s,s),n.push(s)}if(li(n,m,i)){if(a)return!0;v=!0;const h=this.createContactEquation(o,r,t,s,c,l);m.scale(-p,h.ri),m.negate(h.ni);const w=u.get();m.scale(-x,w);const f=u.get();m.scale(-p,f),i.vsub(e,h.rj),h.rj.vadd(f,h.rj),h.rj.vadd(w,h.rj),h.rj.vadd(e,h.rj),h.rj.vsub(r.position,h.rj),h.ri.vadd(i,h.ri),h.ri.vsub(o.position,h.ri),u.release(w),u.release(f),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult);for(let t=0,s=n.length;t!==s;t++)u.release(n[t]);return}for(let w=0;w!==g.length;w++){const f=u.get(),v=u.get();h.vmult(d[g[(w+1)%g.length]],f),h.vmult(d[g[(w+2)%g.length]],v),e.vadd(f,f),e.vadd(v,v);const m=Mi;v.vsub(f,m);const y=bi;m.unit(y);const M=u.get(),b=u.get();i.vsub(f,b);const x=b.dot(y);y.scale(x,M),M.vadd(f,M);const $=u.get();if(M.vsub(i,$),x>0&&x*x<m.lengthSquared()&&$.lengthSquared()<p*p){if(a)return!0;const h=this.createContactEquation(o,r,t,s,c,l);M.vsub(e,h.rj),M.vsub(i,h.ni),h.ni.normalize(),h.ni.scale(p,h.ri),h.rj.vadd(e,h.rj),h.rj.vsub(r.position,h.rj),h.ri.vadd(i,h.ri),h.ri.vsub(o.position,h.ri),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult);for(let t=0,s=n.length;t!==s;t++)u.release(n[t]);return u.release(f),u.release(v),u.release(M),u.release($),void u.release(b)}u.release(f),u.release(v),u.release(M),u.release($),u.release(b)}for(let t=0,s=n.length;t!==s;t++)u.release(n[t])}}}planeConvex(t,s,i,e,n,h,o,r,c,l,a){const u=Fi,w=Pi;w.set(0,0,1),n.vmult(w,w);let f=0;const d=Ei;for(let n=0;n!==s.vertices.length;n++)if(u.copy(s.vertices[n]),h.vmult(u,u),e.vadd(u,u),u.vsub(i,d),w.dot(d)<=0){if(a)return!0;const n=this.createContactEquation(o,r,t,s,c,l),h=Ti;w.scale(w.dot(d),h),u.vsub(h,h),h.vsub(i,n.ri),n.ni.copy(w),u.vsub(e,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),n.rj.vadd(e,n.rj),n.rj.vsub(r.position,n.rj),this.result.push(n),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}boxConvex(t,s,i,e,n,h,o,r,c,l,a){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,s,i,e,n,h,o,r,t,s,a)}sphereHeightfield(t,s,i,e,n,h,o,r,c,l,a){const u=s.data,w=t.radius,f=s.elementSize,d=Xi,p=zi;y.pointToLocalFrame(e,h,i,p);let v=Math.floor((p.x-w)/f)-1,g=Math.ceil((p.x+w)/f)+1,m=Math.floor((p.y-w)/f)-1,M=Math.ceil((p.y+w)/f)+1;if(g<0||M<0||v>u.length||m>u[0].length)return;v<0&&(v=0),g<0&&(g=0),m<0&&(m=0),M<0&&(M=0),v>=u.length&&(v=u.length-1),g>=u.length&&(g=u.length-1),M>=u[0].length&&(M=u[0].length-1),m>=u[0].length&&(m=u[0].length-1);const b=[];if(s.getRectMinMax(v,m,g,M,b),p.z-w>b[1]||p.z+w<b[0])return;const x=this.result;for(let c=v;c<g;c++)for(let l=m;l<M;l++){const u=x.length;let w=!1;if(s.getConvexTrianglePillar(c,l,!1),y.pointToWorldFrame(e,h,s.pillarOffset,d),i.distanceTo(d)<s.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(w=this.sphereConvex(t,s.pillarConvex,i,d,n,h,o,r,t,s,a)),a&&w)return!0;if(s.getConvexTrianglePillar(c,l,!0),y.pointToWorldFrame(e,h,s.pillarOffset,d),i.distanceTo(d)<s.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(w=this.sphereConvex(t,s.pillarConvex,i,d,n,h,o,r,t,s,a)),a&&w)return!0;if(x.length-u>2)return}}boxHeightfield(t,s,i,e,n,h,o,r,c,l,a){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,s,i,e,n,h,o,r,t,s,a)}convexHeightfield(t,s,i,e,n,h,o,r,c,l,a){const u=s.data,w=s.elementSize,f=t.boundingSphereRadius,d=Di,p=Gi,v=Ui;y.pointToLocalFrame(e,h,i,v);let g=Math.floor((v.x-f)/w)-1,m=Math.ceil((v.x+f)/w)+1,M=Math.floor((v.y-f)/w)-1,b=Math.ceil((v.y+f)/w)+1;if(m<0||b<0||g>u.length||M>u[0].length)return;g<0&&(g=0),m<0&&(m=0),M<0&&(M=0),b<0&&(b=0),g>=u.length&&(g=u.length-1),m>=u.length&&(m=u.length-1),b>=u[0].length&&(b=u[0].length-1),M>=u[0].length&&(M=u[0].length-1);const x=[];if(s.getRectMinMax(g,M,m,b,x),!(v.z-f>x[1]||v.z+f<x[0]))for(let c=g;c<m;c++)for(let l=M;l<b;l++){let u=!1;if(s.getConvexTrianglePillar(c,l,!1),y.pointToWorldFrame(e,h,s.pillarOffset,d),i.distanceTo(d)<s.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(u=this.convexConvex(t,s.pillarConvex,i,d,n,h,o,r,null,null,a,p,null)),a&&u)return!0;if(s.getConvexTrianglePillar(c,l,!0),y.pointToWorldFrame(e,h,s.pillarOffset,d),i.distanceTo(d)<s.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(u=this.convexConvex(t,s.pillarConvex,i,d,n,h,o,r,null,null,a,p,null)),a&&u)return!0}}sphereParticle(t,s,i,e,n,h,o,r,c,l,a){const u=Ri;if(u.set(0,0,1),e.vsub(i,u),u.lengthSquared()<=t.radius*t.radius){if(a)return!0;const i=this.createContactEquation(r,o,s,t,c,l);u.normalize(),i.rj.copy(u),i.rj.scale(t.radius,i.rj),i.ni.copy(u),i.ni.negate(i.ni),i.ri.set(0,0,0),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}planeParticle(t,s,i,e,n,h,o,r,c,l,a){const u=_i;u.set(0,0,1),o.quaternion.vmult(u,u);const w=Li;if(e.vsub(o.position,w),u.dot(w)<=0){if(a)return!0;const i=this.createContactEquation(r,o,s,t,c,l);i.ni.copy(u),i.ni.negate(i.ni),i.ri.set(0,0,0);const n=Wi;u.scale(u.dot(e),n),e.vsub(n,n),i.rj.copy(n),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}boxParticle(t,s,i,e,n,h,o,r,c,l,a){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,s,i,e,n,h,o,r,t,s,a)}convexParticle(t,s,i,e,n,h,o,r,c,l,a){let u=-1;const w=ji,f=Oi;let d=null;const p=Zi;if(p.copy(e),p.vsub(i,p),n.conjugate(qi),qi.vmult(p,p),t.pointIsInside(p)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(i,n),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(n);for(let s=0,i=t.faces.length;s!==i;s++){const i=t.worldFaceNormals[s];e.vsub(t.worldVertices[t.faces[s][0]],Hi);const n=-i.dot(Hi);if(null===d||Math.abs(n)<Math.abs(d)){if(a)return!0;d=n,u=s,w.copy(i)}}if(-1!==u){const n=this.createContactEquation(r,o,s,t,c,l);w.scale(d,f),f.vadd(e,f),f.vsub(i,f),n.rj.copy(f),w.negate(n.ni),n.ri.set(0,0,0);const h=n.ri,a=n.rj;h.vadd(e,h),h.vsub(r.position,h),a.vadd(i,a),a.vsub(o.position,a),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,s,i,e,n,h,o,r,c,l,a){return this.convexHeightfield(s,t,e,i,h,n,r,o,c,l,a)}particleCylinder(t,s,i,e,n,h,o,r,c,l,a){return this.convexParticle(s,t,e,i,h,n,r,o,c,l,a)}sphereTrimesh(t,s,i,e,n,h,o,r,c,l,a){const u=zs,w=Xs,f=Ys,d=Vs,p=Qs,v=Ks,g=ii,m=Gs,M=Us,b=ei;y.pointToLocalFrame(e,h,i,p);const x=t.radius;g.lowerBound.set(p.x-x,p.y-x,p.z-x),g.upperBound.set(p.x+x,p.y+x,p.z+x),s.getTrianglesInAABB(g,b);const $=Ds,A=t.radius*t.radius;for(let n=0;n<b.length;n++)for(let u=0;u<3;u++)if(s.getVertex(s.indices[3*b[n]+u],$),$.vsub(p,M),M.lengthSquared()<=A){if(m.copy($),y.pointToWorldFrame(e,h,m,$),$.vsub(i,M),a)return!0;let n=this.createContactEquation(o,r,t,s,c,l);n.ni.copy(M),n.ni.normalize(),n.ri.copy(n.ni),n.ri.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),n.rj.copy($),n.rj.vsub(r.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}for(let n=0;n<b.length;n++)for(let g=0;g<3;g++){s.getVertex(s.indices[3*b[n]+g],u),s.getVertex(s.indices[3*b[n]+(g+1)%3],w),w.vsub(u,f),p.vsub(w,v);const m=v.dot(f);p.vsub(u,v);let M=v.dot(f);if(M>0&&m<0&&(p.vsub(u,v),d.copy(f),d.normalize(),M=v.dot(d),d.scale(M,v),v.vadd(u,v),v.distanceTo(p)<t.radius)){if(a)return!0;const n=this.createContactEquation(o,r,t,s,c,l);v.vsub(p,n.ni),n.ni.normalize(),n.ni.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),y.pointToWorldFrame(e,h,v,v),v.vsub(r.position,n.rj),y.vectorToWorldFrame(h,n.ni,n.ni),y.vectorToWorldFrame(h,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}const B=Js,k=ti,S=si,C=Os;for(let n=0,u=b.length;n!==u;n++){s.getTriangleVertices(b[n],B,k,S),s.getNormal(b[n],C),p.vsub(B,v);let u=v.dot(C);if(C.scale(u,v),p.vsub(v,v),u=v.distanceTo(p),it.pointInTriangle(v,B,k,S)&&u<t.radius){if(a)return!0;let n=this.createContactEquation(o,r,t,s,c,l);v.vsub(p,n.ni),n.ni.normalize(),n.ni.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(o.position,n.ri),y.pointToWorldFrame(e,h,v,v),v.vsub(r.position,n.rj),y.vectorToWorldFrame(h,n.ni,n.ni),y.vectorToWorldFrame(h,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}b.length=0}planeTrimesh(t,s,i,e,n,h,r,c,l,a,u){const w=new o,f=Zs;f.set(0,0,1),n.vmult(f,f);for(let n=0;n<s.vertices.length/3;n++){s.getVertex(n,w);const d=new o;d.copy(w),y.pointToWorldFrame(e,h,d,w);const p=js;if(w.vsub(i,p),f.dot(p)<=0){if(u)return!0;const i=this.createContactEquation(r,c,t,s,l,a);i.ni.copy(f);const e=Hs;f.scale(p.dot(f),e),w.vsub(e,e),i.ri.copy(e),i.ri.vsub(r.position,i.ri),i.rj.copy(w),i.rj.vsub(c.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}}}const Is=new o,Ns=new o,_s=new o,Ls=new o,Ws=new o,Rs=new p,qs=new p,Zs=new o,js=new o,Hs=new o,Os=new o,Us=new o;new o;const Ds=new o,Gs=new o,zs=new o,Xs=new o,Ys=new o,Vs=new o,Qs=new o,Ks=new o,Js=new o,ti=new o,si=new o,ii=new a,ei=[],ni=new o,hi=new o,oi=new o,ri=new o,ci=new o;function li(t,s,i){let e=null;const n=t.length;for(let h=0;h!==n;h++){const o=t[h],r=oi;t[(h+1)%n].vsub(o,r);const c=ri;r.cross(s,c);const l=ci;i.vsub(o,l);const a=c.dot(l);if(!(null===e||a>0&&!0===e||a<=0&&!1===e))return!1;null===e&&(e=a>0)}return!0}const ai=new o,ui=new o,wi=new o,fi=new o,di=[new o,new o,new o,new o,new o,new o],pi=new o,vi=new o,gi=new o,mi=new o,yi=new o,Mi=new o,bi=new o,xi=new o,$i=new o,Ai=new o,Bi=new o,ki=new o,Si=new o,Ci=new o;new o,new o;const Fi=new o,Pi=new o,Ei=new o,Ti=new o,Ii=new o,Ni=new o,_i=new o,Li=new o,Wi=new o,Ri=new o,qi=new p,Zi=new o;new o;const ji=new o,Hi=new o,Oi=new o,Ui=new o,Di=new o,Gi=[0],zi=new o,Xi=new o;class Yi{constructor(){this.current=[],this.previous=[]}getKey(t,s){if(s<t){const i=s;s=t,t=i}return t<<16|s}set(t,s){const i=this.getKey(t,s),e=this.current;let n=0;for(;i>e[n];)n++;if(i!==e[n]){for(let t=e.length-1;t>=n;t--)e[t+1]=e[t];e[n]=i}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,s){const i=this.current,e=this.previous,n=i.length,h=e.length;let o=0;for(let s=0;s<n;s++){let n=!1;const h=i[s];for(;h>e[o];)o++;n=h===e[o],n||Vi(t,h)}o=0;for(let t=0;t<h;t++){let n=!1;const h=e[t];for(;h>i[o];)o++;n=i[o]===h,n||Vi(s,h)}}}function Vi(t,s){t.push((4294901760&s)>>16,65535&s)}const Qi=(t,s)=>t<s?`${t}-${s}`:`${s}-${t}`;class Ki{constructor(){this.data={keys:[]}}get(t,s){const i=Qi(t,s);return this.data[i]}set(t,s,i){const e=Qi(t,s);this.get(t,s)||this.data.keys.push(e),this.data[e]=i}delete(t,s){const i=Qi(t,s),e=this.data.keys.indexOf(i);-1!==e&&this.data.keys.splice(e,1),delete this.data[i]}reset(){const t=this.data,s=t.keys;for(;s.length>0;)delete t[s.pop()]}}class Ji extends d{constructor(t){void 0===t&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==t.quatNormalizeSkip?t.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==t.quatNormalizeFast&&t.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new o,t.gravity&&this.gravity.copy(t.gravity),this.broadphase=void 0!==t.broadphase?t.broadphase:new z,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==t.solver?t.solver:new is,this.constraints=[],this.narrowphase=new Ts(this),this.collisionMatrix=new f,this.collisionMatrixPrevious=new f,this.bodyOverlapKeeper=new Yi,this.shapeOverlapKeeper=new Yi,this.contactmaterials=[],this.contactMaterialTable=new Ki,this.defaultMaterial=new Kt("default"),this.defaultContactMaterial=new Qt(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,s){return this.contactMaterialTable.get(t.id,s.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const s=this.constraints.indexOf(t);-1!==s&&this.constraints.splice(s,1)}rayTest(t,s,i){i instanceof X?this.raycastClosest(t,s,{skipBackfaces:!0},i):this.raycastAll(t,s,{skipBackfaces:!0},i)}raycastAll(t,s,i,e){return void 0===i&&(i={}),i.mode=it.ALL,i.from=t,i.to=s,i.callback=e,te.intersectWorld(this,i)}raycastAny(t,s,i,e){return void 0===i&&(i={}),i.mode=it.ANY,i.from=t,i.to=s,i.result=e,te.intersectWorld(this,i)}raycastClosest(t,s,i,e){return void 0===i&&(i={}),i.mode=it.CLOSEST,i.from=t,i.to=s,i.result=e,te.intersectWorld(this,i)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof F&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const s=this.bodies.length-1,i=this.bodies,e=i.indexOf(t);if(-1!==e){i.splice(e,1);for(let t=0;t!==i.length;t++)i[t].index=t;this.collisionMatrix.setNumObjects(s),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const s=this.bodies;for(let i=0;i<s.length;i++){const e=s[i].shapes;for(let s=0;s<e.length;s++){const i=e[s];if(i.id===t)return i}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const s=this.contactmaterials.indexOf(t);-1!==s&&(this.contactmaterials.splice(s,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,s){void 0===t&&(t=1/60),void 0===s&&(s=10);const i=se.now()/1e3;this.step(t,this.lastCallTime?i-this.lastCallTime:void 0,s),this.lastCallTime=i}step(t,s,i){if(void 0===i&&(i=10),void 0===s)this.internalStep(t),this.time+=t;else{this.accumulator+=s;const e=se.now();let n=0;for(;this.accumulator>=t&&n<i&&(this.internalStep(t),this.accumulator-=t,n++,!(se.now()-e>1e3*t)););this.accumulator=this.accumulator%t;const h=this.accumulator/t;for(let t=0;t!==this.bodies.length;t++){const s=this.bodies[t];s.previousPosition.lerp(s.position,h,s.interpolatedPosition),s.previousQuaternion.slerp(s.quaternion,h,s.interpolatedQuaternion),s.previousQuaternion.normalize()}this.time+=s}}internalStep(t){this.dt=t;const s=this.contacts,i=re,e=ce,n=this.bodies.length,h=this.bodies,o=this.solver,r=this.gravity,c=this.doProfiling,l=this.profile,a=F.DYNAMIC;let u=-1/0;const w=this.constraints,f=oe;r.length();const d=r.x,p=r.y,v=r.z;let g=0;for(c&&(u=se.now()),g=0;g!==n;g++){const t=h[g];if(t.type===a){const s=t.force,i=t.mass;s.x+=i*d,s.y+=i*p,s.z+=i*v}}for(let t=0,s=this.subsystems.length;t!==s;t++)this.subsystems[t].update();c&&(u=se.now()),i.length=0,e.length=0,this.broadphase.collisionPairs(this,i,e),c&&(l.broadphase=se.now()-u);let m=w.length;for(g=0;g!==m;g++){const t=w[g];if(!t.collideConnected)for(let s=i.length-1;s>=0;s-=1)(t.bodyA===i[s]&&t.bodyB===e[s]||t.bodyB===i[s]&&t.bodyA===e[s])&&(i.splice(s,1),e.splice(s,1))}this.collisionMatrixTick(),c&&(u=se.now());const y=he,M=s.length;for(g=0;g!==M;g++)y.push(s[g]);s.length=0;const b=this.frictionEquations.length;for(g=0;g!==b;g++)f.push(this.frictionEquations[g]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(i,e,this,s,y,this.frictionEquations,f),c&&(l.narrowphase=se.now()-u),c&&(u=se.now()),g=0;g<this.frictionEquations.length;g++)o.addEquation(this.frictionEquations[g]);const x=s.length;for(let t=0;t!==x;t++){const i=s[t],e=i.bi,n=i.bj,h=i.si,r=i.sj;e.material&&n.material&&this.getContactMaterial(e.material,n.material),e.material&&n.material&&e.material.restitution>=0&&n.material.restitution>=0&&(i.restitution=e.material.restitution*n.material.restitution),o.addEquation(i),e.allowSleep&&e.type===F.DYNAMIC&&e.sleepState===F.SLEEPING&&n.sleepState===F.AWAKE&&n.type!==F.STATIC&&n.velocity.lengthSquared()+n.angularVelocity.lengthSquared()>=2*n.sleepSpeedLimit**2&&(e.wakeUpAfterNarrowphase=!0),n.allowSleep&&n.type===F.DYNAMIC&&n.sleepState===F.SLEEPING&&e.sleepState===F.AWAKE&&e.type!==F.STATIC&&e.velocity.lengthSquared()+e.angularVelocity.lengthSquared()>=2*e.sleepSpeedLimit**2&&(n.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(e,n,!0),this.collisionMatrixPrevious.get(e,n)||(ne.body=n,ne.contact=i,e.dispatchEvent(ne),ne.body=e,n.dispatchEvent(ne)),this.bodyOverlapKeeper.set(e.id,n.id),this.shapeOverlapKeeper.set(h.id,r.id)}for(this.emitContactEvents(),c&&(l.makeContactConstraints=se.now()-u,u=se.now()),g=0;g!==n;g++){const t=h[g];t.wakeUpAfterNarrowphase&&(t.wakeUp(),t.wakeUpAfterNarrowphase=!1)}for(m=w.length,g=0;g!==m;g++){const t=w[g];t.update();for(let s=0,i=t.equations.length;s!==i;s++)o.addEquation(t.equations[s])}o.solve(t,this),c&&(l.solve=se.now()-u),o.removeAllEquations();const $=Math.pow;for(g=0;g!==n;g++){const s=h[g];if(s.type&a){const i=$(1-s.linearDamping,t),e=s.velocity;e.scale(i,e);const n=s.angularVelocity;if(n){const i=$(1-s.angularDamping,t);n.scale(i,n)}}}this.dispatchEvent(ee),c&&(u=se.now());const A=this.stepnumber%(this.quatNormalizeSkip+1)==0,B=this.quatNormalizeFast;for(g=0;g!==n;g++)h[g].integrate(t,A,B);this.clearForces(),this.broadphase.dirty=!0,c&&(l.integrate=se.now()-u),this.stepnumber+=1,this.dispatchEvent(ie);let k=!0;if(this.allowSleep)for(k=!1,g=0;g!==n;g++){const t=h[g];t.sleepTick(this.time),t.sleepState!==F.SLEEPING&&(k=!0)}this.hasActiveBodies=k}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),s=this.hasAnyEventListener("endContact");if((t||s)&&this.bodyOverlapKeeper.getDiff(le,ae),t){for(let t=0,s=le.length;t<s;t+=2)ue.bodyA=this.getBodyById(le[t]),ue.bodyB=this.getBodyById(le[t+1]),this.dispatchEvent(ue);ue.bodyA=ue.bodyB=null}if(s){for(let t=0,s=ae.length;t<s;t+=2)we.bodyA=this.getBodyById(ae[t]),we.bodyB=this.getBodyById(ae[t+1]),this.dispatchEvent(we);we.bodyA=we.bodyB=null}le.length=ae.length=0;const i=this.hasAnyEventListener("beginShapeContact"),e=this.hasAnyEventListener("endShapeContact");if((i||e)&&this.shapeOverlapKeeper.getDiff(le,ae),i){for(let t=0,s=le.length;t<s;t+=2){const s=this.getShapeById(le[t]),i=this.getShapeById(le[t+1]);fe.shapeA=s,fe.shapeB=i,s&&(fe.bodyA=s.body),i&&(fe.bodyB=i.body),this.dispatchEvent(fe)}fe.bodyA=fe.bodyB=fe.shapeA=fe.shapeB=null}if(e){for(let t=0,s=ae.length;t<s;t+=2){const s=this.getShapeById(ae[t]),i=this.getShapeById(ae[t+1]);de.shapeA=s,de.shapeB=i,s&&(de.bodyA=s.body),i&&(de.bodyB=i.body),this.dispatchEvent(de)}de.bodyA=de.bodyB=de.shapeA=de.shapeB=null}}clearForces(){const t=this.bodies,s=t.length;for(let i=0;i!==s;i++){const s=t[i];s.force.set(0,0,0),s.torque.set(0,0,0)}}}new a;const te=new it,se=globalThis.performance||{};if(!se.now){let t=Date.now();se.timing&&se.timing.navigationStart&&(t=se.timing.navigationStart),se.now=()=>Date.now()-t}new o;const ie={type:"postStep"},ee={type:"preStep"},ne={type:F.COLLIDE_EVENT_NAME,body:null,contact:null},he=[],oe=[],re=[],ce=[],le=[],ae=[],ue={type:"beginContact",bodyA:null,bodyB:null},we={type:"endContact",bodyA:null,bodyB:null},fe={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},de={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},pe=class{constructor(s){t(this,s),this.images=[],this.photos=new Map,this.nextIdx=0,this.stepNumber=0,this.data=[],this.simulate=this.simulate.bind(this),this.nextImage=this.nextImage.bind(this),this.addPhoto=this.addPhoto.bind(this)}componentWillLoad(){this.parseImageData(this.data),this.setupSimulation()}parseImageData(t){if("string"==typeof t)this.images=t.split(/,\s?/);else{if(!Array.isArray(t))throw new Error("Invalid data provided");this.images=t}}addPhoto(t){const s=new o(4.4,.01,5.3),i=new k(s),e=new F({mass:1,shape:i,collisionFilterGroup:this.nextIdx+1,collisionFilterMask:99}),n=20*Math.random()-10,h=30*Math.random()+150;e.position.set(5,5,-10.7),e.angularVelocity.set(0,2*Math.random()-1,n),e.velocity.set(0,0,h);const r={contrast:20*Math.random()-10+100,saturation:60*Math.random()+100,brightness:60*Math.random()-30+100,blur:.25*Math.random()+.25,hue:50*Math.random()-25};this.world.addBody(e),this.photos.set(e.id,{imgSrc:t,developed:!1,styles:r})}setupSimulation(){this.world=new Ji({gravity:new o(0,-400,0)}),this.groundBody=new F({type:F.STATIC,shape:new ts,collisionFilterGroup:99}),this.groundBody.position.set(0,0,0),this.groundBody.quaternion.setFromEuler(-Math.PI/2,0,0),this.world.addBody(this.groundBody),this.simulate()}simulate(){requestAnimationFrame(this.simulate),this.world.fixedStep(),this.world.bodies.forEach((t=>{if(this.photos.has(t.id)&&t.velocity.almostZero(.1)){t.type=F.STATIC;const s=this.photos.get(t.id);this.photos.set(t.id,{imgSrc:s.imgSrc,developed:!0,styles:s.styles})}})),this.stepNumber=this.world.stepnumber}renderBodyToCSS(t){const s=36*t.position.x,i=36*t.position.z,e=36*t.position.y,[{x:n,y:h,z:o},r]=t.quaternion.toAxisAngle();return{transform:`translate3d(${s}px, ${i}px, ${e}px) rotate3d(${n}, ${o}, ${h}, ${r}rad)`,boxShadow:`${e}px ${2*e}px ${2*e}px hsl(0deg 0% 0% / 0.35)`}}nextImage(){const t=.4*Math.random()-.2+1,s=1e3*t+300;this.audioEl.playbackRate=t,this.audioEl.play(),setTimeout((()=>{if(this.photos.size<this.images.length)this.addPhoto(this.images[this.nextIdx]),this.nextIdx+=1;else{this.nextIdx===this.images.length&&(this.nextIdx=0),setTimeout((()=>{this.addPhoto(this.images[this.nextIdx]),this.nextIdx+=1}),100);const[t]=this.photos.entries().next().value,s=this.world.bodies.find((s=>s.id==t));this.world.removeBody(s),this.photos.delete(t)}}),s)}render(){const t=s("./assets/polaroid.mp3");return i(e,null,i("audio",{ref:t=>this.audioEl=t,src:t}),i("div",{class:"container",onClick:this.nextImage},this.photos.size>0?this.world.bodies.map((t=>{if(this.photos.has(t.id)){const{imgSrc:s,developed:e,styles:n}=this.photos.get(t.id),h=this.renderBodyToCSS(t);return i("div",{class:"frame",ref:t=>{(null==t?void 0:t.style)&&e&&(t.style.setProperty("--saturation",`${n.saturation}%`),t.style.setProperty("--contrast",`${n.contrast}%`),t.style.setProperty("--hue",`${n.hue}deg`),t.style.setProperty("--brightness",`${n.brightness}%`),t.style.setProperty("--blur",`${n.blur}px`))},style:h},i("img",{class:e?"develop":"",src:s}))}})):i("div",{class:"prompt"},i("h1",null,"Click for next image"))))}static get assetsDirs(){return["assets"]}};function ve(t,s,i,e,n){let h,o,r,c,l=s[0],a=e[0],u=0,w=0;a>l==a>-l?(h=l,l=s[++u]):(h=a,a=e[++w]);let f=0;if(u<t&&w<i)for(a>l==a>-l?(o=l+h,r=h-(o-l),l=s[++u]):(o=a+h,r=h-(o-a),a=e[++w]),h=o,0!==r&&(n[f++]=r);u<t&&w<i;)a>l==a>-l?(o=h+l,c=o-h,r=h-(o-c)+(l-c),l=s[++u]):(o=h+a,c=o-h,r=h-(o-c)+(a-c),a=e[++w]),h=o,0!==r&&(n[f++]=r);for(;u<t;)o=h+l,c=o-h,r=h-(o-c)+(l-c),l=s[++u],h=o,0!==r&&(n[f++]=r);for(;w<i;)o=h+a,c=o-h,r=h-(o-c)+(a-c),a=e[++w],h=o,0!==r&&(n[f++]=r);return 0===h&&0!==f||(n[f++]=h),f}function ge(t){return new Float64Array(t)}pe.style=":host{display:block;font-family:'Raleway', sans-serif}.container{border:1px solid;background:rgb(233, 236, 239);background:linear-gradient(180deg, rgba(233, 236, 239, 1) 26%, rgba(173, 181, 189, 1) 78%);width:900px;height:900px;perspective:1000px;transform-style:preserve-3d;overflow:hidden;--hue:0deg;--contrast:5%;--saturation:150%;--brightness:100%;--blur:1px;cursor:pointer}.frame{padding:15px 15px 55px 15px;background-color:white;width:300px;will-change:transform;transition:transform 0.15s linear;position:absolute}.frame img{height:300px;width:300px;object-fit:cover;transition:filter 4s ease-in;filter:hue-rotate(var(--hue)) contrast(var(--contrast)) saturate(var(--saturation)) brightness(var(--brightness)) blur(var(--blur)) !important}.prompt{width:100%;height:100%;display:flex;justify-content:center;align-items:center}";const me=ge(4),ye=ge(8),Me=ge(12),be=ge(16),xe=ge(4);function $e(t,s,i,e,n,h){const o=(s-h)*(i-n),r=(t-n)*(e-h),c=o-r;if(0===o||0===r||o>0!=r>0)return c;const l=Math.abs(o+r);return Math.abs(c)>=33306690738754716e-32*l?c:-function(t,s,i,e,n,h,o){let r,c,l,a,u,w,f,d,p,v,g,m,y,M,b,x,$,A;const B=t-n,k=i-n,S=s-h,C=e-h;M=B*C,w=134217729*B,f=w-(w-B),d=B-f,w=134217729*C,p=w-(w-C),v=C-p,b=d*v-(M-f*p-d*p-f*v),x=S*k,w=134217729*S,f=w-(w-S),d=S-f,w=134217729*k,p=w-(w-k),v=k-p,$=d*v-(x-f*p-d*p-f*v),g=b-$,u=b-g,me[0]=b-(g+u)+(u-$),m=M+g,u=m-M,y=M-(m-u)+(g-u),g=y-x,u=y-g,me[1]=y-(g+u)+(u-x),A=m+g,u=A-m,me[2]=m-(A-u)+(g-u),me[3]=A;let F=function(t,s){let i=s[0];for(let t=1;t<4;t++)i+=s[t];return i}(0,me),P=22204460492503146e-32*o;if(F>=P||-F>=P)return F;if(u=t-B,r=t-(B+u)+(u-n),u=i-k,l=i-(k+u)+(u-n),u=s-S,c=s-(S+u)+(u-h),u=e-C,a=e-(C+u)+(u-h),0===r&&0===c&&0===l&&0===a)return F;if(P=11093356479670487e-47*o+33306690738754706e-32*Math.abs(F),F+=B*a+C*r-(S*l+k*c),F>=P||-F>=P)return F;M=r*C,w=134217729*r,f=w-(w-r),d=r-f,w=134217729*C,p=w-(w-C),v=C-p,b=d*v-(M-f*p-d*p-f*v),x=c*k,w=134217729*c,f=w-(w-c),d=c-f,w=134217729*k,p=w-(w-k),v=k-p,$=d*v-(x-f*p-d*p-f*v),g=b-$,u=b-g,xe[0]=b-(g+u)+(u-$),m=M+g,u=m-M,y=M-(m-u)+(g-u),g=y-x,u=y-g,xe[1]=y-(g+u)+(u-x),A=m+g,u=A-m,xe[2]=m-(A-u)+(g-u),xe[3]=A;const E=ve(4,me,4,xe,ye);M=B*a,w=134217729*B,f=w-(w-B),d=B-f,w=134217729*a,p=w-(w-a),v=a-p,b=d*v-(M-f*p-d*p-f*v),x=S*l,w=134217729*S,f=w-(w-S),d=S-f,w=134217729*l,p=w-(w-l),v=l-p,$=d*v-(x-f*p-d*p-f*v),g=b-$,u=b-g,xe[0]=b-(g+u)+(u-$),m=M+g,u=m-M,y=M-(m-u)+(g-u),g=y-x,u=y-g,xe[1]=y-(g+u)+(u-x),A=m+g,u=A-m,xe[2]=m-(A-u)+(g-u),xe[3]=A;const T=ve(E,ye,4,xe,Me);M=r*a,w=134217729*r,f=w-(w-r),d=r-f,w=134217729*a,p=w-(w-a),v=a-p,b=d*v-(M-f*p-d*p-f*v),x=c*l,w=134217729*c,f=w-(w-c),d=c-f,w=134217729*l,p=w-(w-l),v=l-p,$=d*v-(x-f*p-d*p-f*v),g=b-$,u=b-g,xe[0]=b-(g+u)+(u-$),m=M+g,u=m-M,y=M-(m-u)+(g-u),g=y-x,u=y-g,xe[1]=y-(g+u)+(u-x),A=m+g,u=A-m,xe[2]=m-(A-u)+(g-u),xe[3]=A;const I=ve(T,Me,4,xe,be);return be[I-1]}(t,s,i,e,n,h,l)}const Ae=Math.pow(2,-52),Be=new Uint32Array(512);class ke{static from(t,s=Te,i=Ie){const e=t.length,n=new Float64Array(2*e);for(let h=0;h<e;h++){const e=t[h];n[2*h]=s(e),n[2*h+1]=i(e)}return new ke(n)}constructor(t){const s=t.length>>1;if(s>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const i=Math.max(2*s-5,0);this._triangles=new Uint32Array(3*i),this._halfedges=new Int32Array(3*i),this._hashSize=Math.ceil(Math.sqrt(s)),this._hullPrev=new Uint32Array(s),this._hullNext=new Uint32Array(s),this._hullTri=new Uint32Array(s),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(s),this._dists=new Float64Array(s),this.update()}update(){const{coords:t,_hullPrev:s,_hullNext:i,_hullTri:e,_hullHash:n}=this,h=t.length>>1;let o=1/0,r=1/0,c=-1/0,l=-1/0;for(let s=0;s<h;s++){const i=t[2*s],e=t[2*s+1];i<o&&(o=i),e<r&&(r=e),i>c&&(c=i),e>l&&(l=e),this._ids[s]=s}const a=(o+c)/2,u=(r+l)/2;let w,f,d,p=1/0;for(let s=0;s<h;s++){const i=Se(a,u,t[2*s],t[2*s+1]);i<p&&(w=s,p=i)}const v=t[2*w],g=t[2*w+1];p=1/0;for(let s=0;s<h;s++){if(s===w)continue;const i=Se(v,g,t[2*s],t[2*s+1]);i<p&&i>0&&(f=s,p=i)}let m=t[2*f],y=t[2*f+1],M=1/0;for(let s=0;s<h;s++){if(s===w||s===f)continue;const i=Fe(v,g,m,y,t[2*s],t[2*s+1]);i<M&&(d=s,M=i)}let b=t[2*d],x=t[2*d+1];if(M===1/0){for(let s=0;s<h;s++)this._dists[s]=t[2*s]-t[0]||t[2*s+1]-t[1];Pe(this._ids,this._dists,0,h-1);const s=new Uint32Array(h);let i=0;for(let t=0,e=-1/0;t<h;t++){const n=this._ids[t];this._dists[n]>e&&(s[i++]=n,e=this._dists[n])}return this.hull=s.subarray(0,i),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if($e(v,g,m,y,b,x)<0){const t=f,s=m,i=y;f=d,m=b,y=x,d=t,b=s,x=i}const $=function(t,s,i,e,n,h){const o=i-t,r=e-s,c=n-t,l=h-s,a=o*o+r*r,u=c*c+l*l,w=.5/(o*l-r*c);return{x:t+(l*a-r*u)*w,y:s+(o*u-c*a)*w}}(v,g,m,y,b,x);this._cx=$.x,this._cy=$.y;for(let s=0;s<h;s++)this._dists[s]=Se(t[2*s],t[2*s+1],$.x,$.y);Pe(this._ids,this._dists,0,h-1),this._hullStart=w;let A=3;i[w]=s[d]=f,i[f]=s[w]=d,i[d]=s[f]=w,e[w]=0,e[f]=1,e[d]=2,n.fill(-1),n[this._hashKey(v,g)]=w,n[this._hashKey(m,y)]=f,n[this._hashKey(b,x)]=d,this.trianglesLen=0,this._addTriangle(w,f,d,-1,-1,-1);for(let h,o,r=0;r<this._ids.length;r++){const c=this._ids[r],l=t[2*c],a=t[2*c+1];if(r>0&&Math.abs(l-h)<=Ae&&Math.abs(a-o)<=Ae)continue;if(h=l,o=a,c===w||c===f||c===d)continue;let u=0;for(let t=0,s=this._hashKey(l,a);t<this._hashSize&&(u=n[(s+t)%this._hashSize],-1===u||u===i[u]);t++);u=s[u];let p,v=u;for(;p=i[v],$e(l,a,t[2*v],t[2*v+1],t[2*p],t[2*p+1])>=0;)if(v=p,v===u){v=-1;break}if(-1===v)continue;let g=this._addTriangle(v,c,i[v],-1,-1,e[v]);e[c]=this._legalize(g+2),e[v]=g,A++;let m=i[v];for(;p=i[m],$e(l,a,t[2*m],t[2*m+1],t[2*p],t[2*p+1])<0;)g=this._addTriangle(m,c,p,e[c],-1,e[m]),e[c]=this._legalize(g+2),i[m]=m,A--,m=p;if(v===u)for(;p=s[v],$e(l,a,t[2*p],t[2*p+1],t[2*v],t[2*v+1])<0;)g=this._addTriangle(p,c,v,-1,e[v],e[p]),this._legalize(g+2),e[p]=g,i[v]=v,A--,v=p;this._hullStart=s[c]=v,i[v]=s[m]=c,i[c]=m,n[this._hashKey(l,a)]=c,n[this._hashKey(t[2*v],t[2*v+1])]=v}this.hull=new Uint32Array(A);for(let t=0,s=this._hullStart;t<A;t++)this.hull[t]=s,s=i[s];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,s){return Math.floor(function(t,s){const i=t/(Math.abs(t)+Math.abs(s));return(s>0?3-i:1+i)/4}(t-this._cx,s-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:s,_halfedges:i,coords:e}=this;let n=0,h=0;for(;;){const o=i[t],r=t-t%3;if(h=r+(t+2)%3,-1===o){if(0===n)break;t=Be[--n];continue}const c=o-o%3,l=c+(o+2)%3,a=s[h],u=s[t],w=s[r+(t+1)%3],f=s[l];if(Ce(e[2*a],e[2*a+1],e[2*u],e[2*u+1],e[2*w],e[2*w+1],e[2*f],e[2*f+1])){s[t]=f,s[o]=a;const e=i[l];if(-1===e){let s=this._hullStart;do{if(this._hullTri[s]===l){this._hullTri[s]=t;break}s=this._hullPrev[s]}while(s!==this._hullStart)}this._link(t,e),this._link(o,i[h]),this._link(h,l);const r=c+(o+1)%3;n<Be.length&&(Be[n++]=r)}else{if(0===n)break;t=Be[--n]}}return h}_link(t,s){this._halfedges[t]=s,-1!==s&&(this._halfedges[s]=t)}_addTriangle(t,s,i,e,n,h){const o=this.trianglesLen;return this._triangles[o]=t,this._triangles[o+1]=s,this._triangles[o+2]=i,this._link(o,e),this._link(o+1,n),this._link(o+2,h),this.trianglesLen+=3,o}}function Se(t,s,i,e){const n=t-i,h=s-e;return n*n+h*h}function Ce(t,s,i,e,n,h,o,r){const c=t-o,l=s-r,a=i-o,u=e-r,w=n-o,f=h-r,d=a*a+u*u,p=w*w+f*f;return c*(u*p-d*f)-l*(a*p-d*w)+(c*c+l*l)*(a*f-u*w)<0}function Fe(t,s,i,e,n,h){const o=i-t,r=e-s,c=n-t,l=h-s,a=o*o+r*r,u=c*c+l*l,w=.5/(o*l-r*c),f=(l*a-r*u)*w,d=(o*u-c*a)*w;return f*f+d*d}function Pe(t,s,i,e){if(e-i<=20)for(let n=i+1;n<=e;n++){const e=t[n],h=s[e];let o=n-1;for(;o>=i&&s[t[o]]>h;)t[o+1]=t[o--];t[o+1]=e}else{let n=i+1,h=e;Ee(t,i+e>>1,n),s[t[i]]>s[t[e]]&&Ee(t,i,e),s[t[n]]>s[t[e]]&&Ee(t,n,e),s[t[i]]>s[t[n]]&&Ee(t,i,n);const o=t[n],r=s[o];for(;;){do{n++}while(s[t[n]]<r);do{h--}while(s[t[h]]>r);if(h<n)break;Ee(t,n,h)}t[i+1]=t[h],t[h]=o,e-n+1>=h-i?(Pe(t,s,n,e),Pe(t,s,i,h-1)):(Pe(t,s,i,h-1),Pe(t,s,n,e))}}function Ee(t,s,i){const e=t[s];t[s]=t[i],t[i]=e}function Te(t){return t[0]}function Ie(t){return t[1]}class Ne{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(t,s){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}`}closePath(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(t,s){this._+=`L${this._x1=+t},${this._y1=+s}`}arc(t,s,i){const e=(t=+t)+(i=+i),n=s=+s;if(i<0)throw new Error("negative radius");null===this._x1?this._+=`M${e},${n}`:(Math.abs(this._x1-e)>1e-6||Math.abs(this._y1-n)>1e-6)&&(this._+="L"+e+","+n),i&&(this._+=`A${i},${i},0,1,1,${t-i},${s}A${i},${i},0,1,1,${this._x1=e},${this._y1=n}`)}rect(t,s,i,e){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}h${+i}v${+e}h${-i}Z`}value(){return this._||null}}class _e{constructor(){this._=[]}moveTo(t,s){this._.push([t,s])}closePath(){this._.push(this._[0].slice())}lineTo(t,s){this._.push([t,s])}value(){return this._.length?this._:null}}class Le{constructor(t,[s,i,e,n]=[0,0,960,500]){if(!((e=+e)>=(s=+s)&&(n=+n)>=(i=+i)))throw new Error("invalid bounds");this.delaunay=t,this._circumcenters=new Float64Array(2*t.points.length),this.vectors=new Float64Array(2*t.points.length),this.xmax=e,this.xmin=s,this.ymax=n,this.ymin=i,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:t,hull:s,triangles:i},vectors:e}=this,n=this.circumcenters=this._circumcenters.subarray(0,i.length/3*2);for(let s,e,h=0,o=0,r=i.length;h<r;h+=3,o+=2){const r=2*i[h],c=2*i[h+1],l=2*i[h+2],a=t[r],u=t[r+1],w=t[l],f=t[l+1],d=t[c]-a,p=t[c+1]-u,v=w-a,g=f-u,m=2*(d*g-p*v);if(Math.abs(m)<1e-9){let n=1e9;const h=2*i[0];n*=Math.sign((t[h]-a)*g-(t[h+1]-u)*v),s=(a+w)/2-n*g,e=(u+f)/2+n*v}else{const t=1/m,i=d*d+p*p,n=v*v+g*g;s=a+(g*i-p*n)*t,e=u+(d*n-v*i)*t}n[o]=s,n[o+1]=e}let h,o,r,c=s[s.length-1],l=4*c,a=t[2*c],u=t[2*c+1];e.fill(0);for(let i=0;i<s.length;++i)c=s[i],h=l,o=a,r=u,l=4*c,a=t[2*c],u=t[2*c+1],e[h+2]=e[l]=r-u,e[h+3]=e[l+1]=a-o}render(t){const s=null==t?t=new Ne:void 0,{delaunay:{halfedges:i,inedges:e,hull:n},circumcenters:h,vectors:o}=this;if(n.length<=1)return null;for(let s=0,e=i.length;s<e;++s){const e=i[s];if(e<s)continue;const n=2*Math.floor(s/3),o=2*Math.floor(e/3);this._renderSegment(h[n],h[n+1],h[o],h[o+1],t)}let r,c=n[n.length-1];for(let s=0;s<n.length;++s){r=c,c=n[s];const i=2*Math.floor(e[c]/3),l=h[i],a=h[i+1],u=4*r,w=this._project(l,a,o[u+2],o[u+3]);w&&this._renderSegment(l,a,w[0],w[1],t)}return s&&s.value()}renderBounds(t){const s=null==t?t=new Ne:void 0;return t.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),s&&s.value()}renderCell(t,s){const i=null==s?s=new Ne:void 0,e=this._clip(t);if(null===e||!e.length)return;s.moveTo(e[0],e[1]);let n=e.length;for(;e[0]===e[n-2]&&e[1]===e[n-1]&&n>1;)n-=2;for(let t=2;t<n;t+=2)e[t]===e[t-2]&&e[t+1]===e[t-1]||s.lineTo(e[t],e[t+1]);return s.closePath(),i&&i.value()}*cellPolygons(){const{delaunay:{points:t}}=this;for(let s=0,i=t.length/2;s<i;++s){const t=this.cellPolygon(s);t&&(t.index=s,yield t)}}cellPolygon(t){const s=new _e;return this.renderCell(t,s),s.value()}_renderSegment(t,s,i,e,n){let h;const o=this._regioncode(t,s),r=this._regioncode(i,e);0===o&&0===r?(n.moveTo(t,s),n.lineTo(i,e)):(h=this._clipSegment(t,s,i,e,o,r))&&(n.moveTo(h[0],h[1]),n.lineTo(h[2],h[3]))}contains(t,s,i){return(s=+s)==s&&(i=+i)==i&&this.delaunay._step(t,s,i)===t}*neighbors(t){const s=this._clip(t);if(s)for(const i of this.delaunay.neighbors(t)){const t=this._clip(i);if(t)t:for(let e=0,n=s.length;e<n;e+=2)for(let h=0,o=t.length;h<o;h+=2)if(s[e]==t[h]&&s[e+1]==t[h+1]&&s[(e+2)%n]==t[(h+o-2)%o]&&s[(e+3)%n]==t[(h+o-1)%o]){yield i;break t}}}_cell(t){const{circumcenters:s,delaunay:{inedges:i,halfedges:e,triangles:n}}=this,h=i[t];if(-1===h)return null;const o=[];let r=h;do{const i=Math.floor(r/3);if(o.push(s[2*i],s[2*i+1]),r=r%3==2?r-2:r+1,n[r]!==t)break;r=e[r]}while(r!==h&&-1!==r);return o}_clip(t){if(0===t&&1===this.delaunay.hull.length)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const s=this._cell(t);if(null===s)return null;const{vectors:i}=this,e=4*t;return i[e]||i[e+1]?this._clipInfinite(t,s,i[e],i[e+1],i[e+2],i[e+3]):this._clipFinite(t,s)}_clipFinite(t,s){const i=s.length;let e,n,h,o,r=null,c=s[i-2],l=s[i-1],a=this._regioncode(c,l),u=0;for(let w=0;w<i;w+=2)if(e=c,n=l,c=s[w],l=s[w+1],h=a,a=this._regioncode(c,l),0===h&&0===a)o=u,u=0,r?r.push(c,l):r=[c,l];else{let s,i,w,f,d;if(0===h){if(null===(s=this._clipSegment(e,n,c,l,h,a)))continue;[i,w,f,d]=s}else{if(null===(s=this._clipSegment(c,l,e,n,a,h)))continue;[f,d,i,w]=s,o=u,u=this._edgecode(i,w),o&&u&&this._edge(t,o,u,r,r.length),r?r.push(i,w):r=[i,w]}o=u,u=this._edgecode(f,d),o&&u&&this._edge(t,o,u,r,r.length),r?r.push(f,d):r=[f,d]}if(r)o=u,u=this._edgecode(r[0],r[1]),o&&u&&this._edge(t,o,u,r,r.length);else if(this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return r}_clipSegment(t,s,i,e,n,h){for(;;){if(0===n&&0===h)return[t,s,i,e];if(n&h)return null;let o,r,c=n||h;8&c?(o=t+(i-t)*(this.ymax-s)/(e-s),r=this.ymax):4&c?(o=t+(i-t)*(this.ymin-s)/(e-s),r=this.ymin):2&c?(r=s+(e-s)*(this.xmax-t)/(i-t),o=this.xmax):(r=s+(e-s)*(this.xmin-t)/(i-t),o=this.xmin),n?n=this._regioncode(t=o,s=r):h=this._regioncode(i=o,e=r)}}_clipInfinite(t,s,i,e,n,h){let o,r=Array.from(s);if((o=this._project(r[0],r[1],i,e))&&r.unshift(o[0],o[1]),(o=this._project(r[r.length-2],r[r.length-1],n,h))&&r.push(o[0],o[1]),r=this._clipFinite(t,r))for(let s,i=0,e=r.length,n=this._edgecode(r[e-2],r[e-1]);i<e;i+=2)s=n,n=this._edgecode(r[i],r[i+1]),s&&n&&(i=this._edge(t,s,n,r,i),e=r.length);else this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(r=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return r}_edge(t,s,i,e,n){for(;s!==i;){let i,h;switch(s){case 5:s=4;continue;case 4:s=6,i=this.xmax,h=this.ymin;break;case 6:s=2;continue;case 2:s=10,i=this.xmax,h=this.ymax;break;case 10:s=8;continue;case 8:s=9,i=this.xmin,h=this.ymax;break;case 9:s=1;continue;case 1:s=5,i=this.xmin,h=this.ymin}e[n]===i&&e[n+1]===h||!this.contains(t,i,h)||(e.splice(n,0,i,h),n+=2)}if(e.length>4)for(let t=0;t<e.length;t+=2){const s=(t+2)%e.length,i=(t+4)%e.length;(e[t]===e[s]&&e[s]===e[i]||e[t+1]===e[s+1]&&e[s+1]===e[i+1])&&(e.splice(s,2),t-=2)}return n}_project(t,s,i,e){let n,h,o,r=1/0;if(e<0){if(s<=this.ymin)return null;(n=(this.ymin-s)/e)<r&&(o=this.ymin,h=t+(r=n)*i)}else if(e>0){if(s>=this.ymax)return null;(n=(this.ymax-s)/e)<r&&(o=this.ymax,h=t+(r=n)*i)}if(i>0){if(t>=this.xmax)return null;(n=(this.xmax-t)/i)<r&&(h=this.xmax,o=s+(r=n)*e)}else if(i<0){if(t<=this.xmin)return null;(n=(this.xmin-t)/i)<r&&(h=this.xmin,o=s+(r=n)*e)}return[h,o]}_edgecode(t,s){return(t===this.xmin?1:t===this.xmax?2:0)|(s===this.ymin?4:s===this.ymax?8:0)}_regioncode(t,s){return(t<this.xmin?1:t>this.xmax?2:0)|(s<this.ymin?4:s>this.ymax?8:0)}}const We=2*Math.PI,Re=Math.pow;function qe(t){return t[0]}function Ze(t){return t[1]}function je(t,s,i){return[t+Math.sin(t+s)*i,s+Math.cos(t-s)*i]}class He{static from(t,s=qe,i=Ze,e){return new He("length"in t?function(t,s,i,e){const n=t.length,h=new Float64Array(2*n);for(let o=0;o<n;++o){const n=t[o];h[2*o]=s.call(e,n,o,t),h[2*o+1]=i.call(e,n,o,t)}return h}(t,s,i,e):Float64Array.from(function*(t,s,i,e){let n=0;for(const h of t)yield s.call(e,h,n,t),yield i.call(e,h,n,t),++n}(t,s,i,e)))}constructor(t){this._delaunator=new ke(t),this.inedges=new Int32Array(t.length/2),this._hullIndex=new Int32Array(t.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const t=this._delaunator,s=this.points;if(t.hull&&t.hull.length>2&&function(t){const{triangles:s,coords:i}=t;for(let t=0;t<s.length;t+=3){const e=2*s[t],n=2*s[t+1],h=2*s[t+2];if((i[h]-i[e])*(i[n+1]-i[e+1])-(i[n]-i[e])*(i[h+1]-i[e+1])>1e-10)return!1}return!0}(t)){this.collinear=Int32Array.from({length:s.length/2},((t,s)=>s)).sort(((t,i)=>s[2*t]-s[2*i]||s[2*t+1]-s[2*i+1]));const t=this.collinear[0],i=this.collinear[this.collinear.length-1],e=[s[2*t],s[2*t+1],s[2*i],s[2*i+1]],n=1e-8*Math.hypot(e[3]-e[1],e[2]-e[0]);for(let t=0,i=s.length/2;t<i;++t){const i=je(s[2*t],s[2*t+1],n);s[2*t]=i[0],s[2*t+1]=i[1]}this._delaunator=new ke(s)}else delete this.collinear;const i=this.halfedges=this._delaunator.halfedges,e=this.hull=this._delaunator.hull,n=this.triangles=this._delaunator.triangles,h=this.inedges.fill(-1),o=this._hullIndex.fill(-1);for(let t=0,s=i.length;t<s;++t){const s=n[t%3==2?t-2:t+1];-1!==i[t]&&-1!==h[s]||(h[s]=t)}for(let t=0,s=e.length;t<s;++t)o[e[t]]=t;e.length<=2&&e.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=e[0],h[e[0]]=1,2===e.length&&(h[e[1]]=0,this.triangles[1]=e[1],this.triangles[2]=e[1]))}voronoi(t){return new Le(this,t)}*neighbors(t){const{inedges:s,hull:i,_hullIndex:e,halfedges:n,triangles:h,collinear:o}=this;if(o){const s=o.indexOf(t);return s>0&&(yield o[s-1]),void(s<o.length-1&&(yield o[s+1]))}const r=s[t];if(-1===r)return;let c=r,l=-1;do{if(yield l=h[c],c=c%3==2?c-2:c+1,h[c]!==t)return;if(c=n[c],-1===c){const s=i[(e[t]+1)%i.length];return void(s!==l&&(yield s))}}while(c!==r)}find(t,s,i=0){if((t=+t)!=t||(s=+s)!=s)return-1;const e=i;let n;for(;(n=this._step(i,t,s))>=0&&n!==i&&n!==e;)i=n;return n}_step(t,s,i){const{inedges:e,hull:n,_hullIndex:h,halfedges:o,triangles:r,points:c}=this;if(-1===e[t]||!c.length)return(t+1)%(c.length>>1);let l=t,a=Re(s-c[2*t],2)+Re(i-c[2*t+1],2);const u=e[t];let w=u;do{let e=r[w];const u=Re(s-c[2*e],2)+Re(i-c[2*e+1],2);if(u<a&&(a=u,l=e),w=w%3==2?w-2:w+1,r[w]!==t)break;if(w=o[w],-1===w){if(w=n[(h[t]+1)%n.length],w!==e&&Re(s-c[2*w],2)+Re(i-c[2*w+1],2)<a)return w;break}}while(w!==u);return l}render(t){const s=null==t?t=new Ne:void 0,{points:i,halfedges:e,triangles:n}=this;for(let s=0,h=e.length;s<h;++s){const h=e[s];if(h<s)continue;const o=2*n[s],r=2*n[h];t.moveTo(i[o],i[o+1]),t.lineTo(i[r],i[r+1])}return this.renderHull(t),s&&s.value()}renderPoints(t,s){void 0!==s||t&&"function"==typeof t.moveTo||(s=t,t=null),s=null==s?2:+s;const i=null==t?t=new Ne:void 0,{points:e}=this;for(let i=0,n=e.length;i<n;i+=2){const n=e[i],h=e[i+1];t.moveTo(n+s,h),t.arc(n,h,s,0,We)}return i&&i.value()}renderHull(t){const s=null==t?t=new Ne:void 0,{hull:i,points:e}=this,n=2*i[0],h=i.length;t.moveTo(e[n],e[n+1]);for(let s=1;s<h;++s){const n=2*i[s];t.lineTo(e[n],e[n+1])}return t.closePath(),s&&s.value()}hullPolygon(){const t=new _e;return this.renderHull(t),t.value()}renderTriangle(t,s){const i=null==s?s=new Ne:void 0,{points:e,triangles:n}=this,h=2*n[t*=3],o=2*n[t+1],r=2*n[t+2];return s.moveTo(e[h],e[h+1]),s.lineTo(e[o],e[o+1]),s.lineTo(e[r],e[r+1]),s.closePath(),i&&i.value()}*trianglePolygons(){const{triangles:t}=this;for(let s=0,i=t.length/3;s<i;++s)yield this.trianglePolygon(s)}trianglePolygon(t){const s=new _e;return this.renderTriangle(t,s),s.value()}}function Oe(t,s){let i;if(void 0===s)for(const s of t)null!=s&&(i<s||void 0===i&&s>=s)&&(i=s);else{let e=-1;for(let n of t)null!=(n=s(n,++e,t))&&(i<n||void 0===i&&n>=n)&&(i=n)}return i}function Ue(t,s){let i;if(void 0===s)for(const s of t)null!=s&&(i>s||void 0===i&&s>=s)&&(i=s);else{let e=-1;for(let n of t)null!=(n=s(n,++e,t))&&(i>n||void 0===i&&n>=n)&&(i=n)}return i}const De=class{constructor(s){t(this,s),this.width=900,this.height=900,this.points=[],this.polygons=[],this.polys=[],this.polyMap=new Map,this.stepNumber=0,this.simulate=this.simulate.bind(this)}componentWillLoad(){this.points=Array.from({length:200},(()=>[Math.random()*this.width,Math.random()*this.height])),this.delaunay=He.from(this.points),this.voronoi=this.delaunay.voronoi([0,0,this.width,this.height]),this.world=new Ji({gravity:new o(0,0,0)});const t=this.voronoi.cellPolygons();let s;do{s=t.next(),!s.done&&s.value&&this.polygons.push(s.value)}while(!s.done);this.populateWorld(this.polygons)}calcPolyDimensionsAndStyles(t){const s=Ue(t,(t=>t[0])),i=Ue(t,(t=>t[1])),e=Oe(t,(t=>t[0])),n=Oe(t,(t=>t[1])),h=e-s,o=n-i,r=`polygon(${t.map((t=>`${t[0]-s}px ${t[1]-i}px`)).join()})`;return{xMin:s,yMin:i,xMax:e,yMax:n,width:h,height:o,clipPath:r,backgroundImage:`url(${this.src})`,backgroundPosition:`left -${s}px top -${i}px`}}populateWorld(t){t.forEach((t=>{const s=this.calcPolyDimensionsAndStyles(t),i=new k(new o(s.width/2,s.height/2,5)),e=new o(s.xMin,s.yMin,1),n=new F({shape:i,position:e,mass:1,collisionFilterMask:2,collisionFilterGroup:1});this.polyMap.set(n.id,s),this.world.addBody(n)}));const s=new F({shape:new Jt(this.width/2),mass:100,collisionFilterGroup:2});s.position=new o(this.width/2,this.height/2,2*-this.width),s.velocity=new o(0,0,1e3),s.addEventListener("collide",(t=>{this.imageEl.hidden=!0,t.target.collisionFilterGroup=2})),this.world.addBody(s)}renderBodyToCSS(t){const s=t.position.x,i=t.position.y,e=t.position.z,[{x:n,y:h,z:o},r]=t.quaternion.toAxisAngle(),c=`${e+1}px ${2*e+1}px ${2*e+1}px black`;return{transform:`translate3d(${s}px, ${i}px, ${e}px) rotate3d(${n}, ${o}, ${h}, ${r}rad)`,zIndex:`${Math.trunc(e)}`,boxShadow:c}}simulate(){requestAnimationFrame(this.simulate),this.world.fixedStep(),this.stepNumber=this.world.stepnumber}render(){return i(e,null,i("div",{class:"container",style:{width:`${this.width}px`,height:`${this.height}px`},onClick:this.simulate},this.world.bodies.map((t=>{if(this.polyMap.has(t.id)){const s=this.renderBodyToCSS(t),{clipPath:e,backgroundImage:n,backgroundPosition:h,width:o,height:r}=this.polyMap.get(t.id),c=Object.assign(Object.assign({},s),{clipPath:e,backgroundImage:n,backgroundPosition:h,width:`${o}px`,height:`${r}px`});return i("div",{class:"poly",style:c})}return null})),i("img",{ref:t=>this.imageEl=t,src:this.src})))}};De.style=":host{display:block}img{width:900px;height:900px;object-fit:cover}.poly{background-size:900 900;position:absolute;will-change:transform;transform-style:preserve-3d;z-index:-1;}.container{perspective:1000px;overflow:hidden}";export{pe as polaroid_img,De as shatter_img}